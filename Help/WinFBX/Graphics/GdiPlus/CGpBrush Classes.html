<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta http-equiv='X-UA-Compatible' content='IE=edge' />
  <meta http-equiv='MSThemeCompatible' content='Yes'>

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>CGpBrush Classes</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">@font-face {font-family: octicons-link;src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');}body {-webkit-text-size-adjust: 100%;text-size-adjust: 100%;color: #333;font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";font-size: 16px;line-height: 1.6;word-wrap: break-word;max-width: 99%;box-sizing: border-box;padding: 20px 5px 8rem 5px; margin-left: auto;margin-right: auto;}body a {background-color: transparent;}body a:active,body a:hover {outline: 0;}body strong {font-weight: bold;}body h1 {font-size: 2em;margin: 0.67em 0;}body img {border: 0;}body hr {box-sizing: content-box;height: 0;}body pre {overflow: auto;}body code,body kbd,body pre {font-family: monospace, monospace;font-size: 1em;}body input {color: inherit;font: inherit;margin: 0;}body html input[disabled] {cursor: default;}body input {line-height: normal;}body input[type="checkbox"] {box-sizing: border-box;padding: 0;}body table {border-collapse: collapse;border-spacing: 0;}body td,body th {padding: 0;}body * {box-sizing: border-box;}body input {font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";}body a {color: #4078c0;text-decoration: none;}body a:hover,body a:active {text-decoration: underline;}body hr {height: 0;margin: 15px 0;overflow: hidden;background: transparent;border: 0;border-bottom: 1px solid #ddd;}body hr:before {display: table;content: "";}body hr:after {display: table;clear: both;content: "";}body h1,body h2,body h3,body h4,body h5,body h6 {margin-top: 15px;margin-bottom: 15px;line-height: 1.1;}body h1 {font-size: 30px;}body h2 {font-size: 21px;}body h3 {font-size: 16px;}body h4 {font-size: 14px;}body h5 {font-size: 12px;}body h6 {font-size: 11px;}body blockquote {margin: 0;}body ul,body ol {padding: 0;margin-top: 0;margin-bottom: 0;}body ol ol,body ul ol {list-style-type: lower-roman;}body ul ul ol,body ul ol ol,body ol ul ol,body ol ol ol {list-style-type: lower-alpha;}body dd {margin-left: 0;}body code {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 12px;}body pre {margin-top: 0;margin-bottom: 0;font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;}body .select::-ms-expand {opacity: 0;}body .octicon {font: normal normal normal 16px/1 octicons-link;display: inline-block;text-decoration: none;text-rendering: auto;-webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;}body .octicon-link:before {content: '\f05c';}body:before {display: table;content: "";}body:after {display: table;clear: both;content: "";}body>*:first-child {margin-top: 0 !important;}body>*:last-child {margin-bottom: 0 !important;}body a:not([href]) {color: inherit;text-decoration: none;}body .anchor {display: inline-block;padding-right: 2px;margin-left: -18px;}body .anchor:focus {outline: none;}body h1,body h2,body h3,body h4,body h5,body h6 {margin-top: 1em;margin-bottom: 16px;font-weight: bold;line-height: 1.4;}body h1 .octicon-link,body h2 .octicon-link,body h3 .octicon-link,body h4 .octicon-link,body h5 .octicon-link,body h6 .octicon-link {color: #000;vertical-align: middle;visibility: hidden;}body h1:hover .anchor,body h2:hover .anchor,body h3:hover .anchor,body h4:hover .anchor,body h5:hover .anchor,body h6:hover .anchor {text-decoration: none;}body h1:hover .anchor .octicon-link,body h2:hover .anchor .octicon-link,body h3:hover .anchor .octicon-link,body h4:hover .anchor .octicon-link,body h5:hover .anchor .octicon-link,body h6:hover .anchor .octicon-link {visibility: visible;}body h1 {padding-bottom: 0.3em;font-size: 1.75em;line-height: 1.2;}body h1 .anchor {line-height: 1;}body h2 {padding-bottom: 0.3em;font-size: 1.5em;line-height: 1.225;}body h2 .anchor {line-height: 1;}body h3 {font-size: 1.25em;line-height: 1.43;}body h3 .anchor {line-height: 1.2;}body h4 {font-size: 1em;}body h4 .anchor {line-height: 1.2;}body h5 {font-size: 1em;}body h5 .anchor {line-height: 1.1;}body h6 {font-size: 1em;color: #777;}body h6 .anchor {line-height: 1.1;}body p,body blockquote,body ul,body ol,body dl,body table,body pre {margin-top: 0;margin-bottom: 16px;}body hr {height: 4px;padding: 0;margin: 16px 0;background-color: #e7e7e7;border: 0 none;}body ul,body ol {padding-left: 2em;}body ul ul,body ul ol,body ol ol,body ol ul {margin-top: 0;margin-bottom: 0;}body li>p {margin-top: 16px;}body dl {padding: 0;}body dl dt {padding: 0;margin-top: 16px;font-size: 1em;font-style: italic;font-weight: bold;}body dl dd {padding: 0 16px;margin-bottom: 16px;}body blockquote {padding: 0 15px;color: #777;border-left: 4px solid #ddd;}body blockquote>:first-child {margin-top: 0;}body blockquote>:last-child {margin-bottom: 0;}body table {display: block;width: 100%;overflow: auto;word-break: normal;word-break: keep-all;}body table th {font-weight: bold;}body table th,body table td {padding: 6px 13px;border: 1px solid #ddd;}body table tr {background-color: #fff;border-top: 1px solid #ccc;}body table tr:nth-child(2n) {background-color: #f8f8f8;}body img {max-width: 100%;box-sizing: content-box;background-color: #fff;}body code {padding: 0;padding-top: 0;padding-bottom: 0;margin: 0;font-size: 85%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}body code:before,body code:after {letter-spacing: -0.2em;content: "\00a0";}body pre>code {padding: 0;margin: 0;font-size: 100%;word-break: normal;white-space: pre;background: transparent;border: 0;}body .highlight {margin-bottom: 16px;}body .highlight pre,body pre {padding: 16px;overflow: auto;font-size: 85%;line-height: 1.45;background-color: #f7f7f7;border-radius: 3px;}body .highlight pre {margin-bottom: 0;word-break: normal;}body pre {word-wrap: normal;}body pre code {display: inline;max-width: initial;padding: 0;margin: 0;overflow: initial;line-height: inherit;word-wrap: normal;background-color: transparent;border: 0;}body pre code:before,body pre code:after {content: normal;}body kbd {display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb;}body .pl-c {color: #969896;}body .pl-c1,body .pl-s .pl-v {color: #0086b3;}body .pl-e,body .pl-en {color: #795da3;}body .pl-s .pl-s1,body .pl-smi {color: #333;}body .pl-ent {color: #63a35c;}body .pl-k {color: #a71d5d;}body .pl-pds,body .pl-s,body .pl-s .pl-pse .pl-s1,body .pl-sr,body .pl-sr .pl-cce,body .pl-sr .pl-sra,body .pl-sr .pl-sre {color: #183691;}body .pl-v {color: #ed6a43;}body .pl-id {color: #b52a1d;}body .pl-ii {background-color: #b52a1d;color: #f8f8f8;}body .pl-sr .pl-cce {color: #63a35c;font-weight: bold;}body .pl-ml {color: #693a17;}body .pl-mh,body .pl-mh .pl-en,body .pl-ms {color: #1d3e81;font-weight: bold;}body .pl-mq {color: #008080;}body .pl-mi {color: #333;font-style: italic;}body .pl-mb {color: #333;font-weight: bold;}body .pl-md {background-color: #ffecec;color: #bd2c00;}body .pl-mi1 {background-color: #eaffea;color: #55a532;}body .pl-mdr {color: #795da3;font-weight: bold;}body .pl-mo {color: #1d3e81;}body kbd {display: inline-block;padding: 3px 5px;font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb;}body .task-list-item {list-style-type: none;}body .task-list-item+.task-list-item {margin-top: 3px;}body .task-list-item input {margin: 0 0.35em 0.25em -1.6em;vertical-align: middle;}body :checked+.radio-label {z-index: 1;position: relative;border-color: #4078c0;}</style>
  
    
  
</head>
<body>
<h1 id="cgpbrush-class">CGpBrush Class</h1>
<p>The <strong>CGpBrush</strong> class is a base interface that defines a <strong>Brush</strong> object. A <strong>Brush</strong> object is used to paint the interior of graphics shapes, such as rectangles, ellipses, pies, polygons, and paths. You must not instantiate the <strong>CGpBrush</strong> class, but to use one of its derived classes.</p>
<p>A closed shape, such as a rectangle or an ellipse, consists of an outline and an interior. The outline is drawn with a pen and the interior is filled with a brush. GDI+ provides several brush classes for filling the interiors of closed shapes: <strong>CGpSolidBrush</strong>, <strong>CGpHatchBrush</strong>, <strong>CGpTextureBrush</strong>, <strong>CGpLinearGradientBrush</strong>, and <strong>CGpPathGradientBrush</strong>. All of these classes inherit from the <strong>CGpBrush</strong> class.</p>
<p><strong>Inherits from</strong>: CGpBase.<br> <strong>Include file</strong>: CGpBrush.inc.</p>
<h3 id="methods">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ConstructorsBrush">Constructors</a></td>
<td>Creates a <strong>Brush</strong> object from another <strong>Brush</strong> object.</td>
</tr>
<tr class="even">
<td><a href="#CloneBrush">Clone</a></td>
<td>Copies the contents of the existing <strong>Brush</strong> object into a new <strong>Brush</strong> object.</td>
</tr>
<tr class="odd">
<td><a href="#GetTypeBrush">GetType</a></td>
<td>Gets the type of this brush.</td>
</tr>
</tbody>
</table>
<h1 id="cgpsolidbrush-class">CGpSolidBrush Class</h1>
<p>The <strong>SolidBrush</strong> object defines a solid color Brush object. A <strong>Brush</strong> object is used to fill in shapes similar to the way a paint brush can paint the inside of a shape.</p>
<p><strong>Inherits from</strong>: CGpBrush.<br> <strong>Include file</strong>: CGpBrush.inc.</p>
<h3 id="methods-1">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ConstructorSolidBrush">Constructors</a></td>
<td>Creates a <strong>SolidBrush</strong> object based on a color.</td>
</tr>
<tr class="even">
<td><a href="#GetColorSolidBrush">GetColor</a></td>
<td>Gets the color of this brush.</td>
</tr>
<tr class="odd">
<td><a href="#SetColorSolidBrush">SetColor</a></td>
<td>Sets the color of this brush.</td>
</tr>
</tbody>
</table>
<h1 id="cgphatchbrush-class">CGpHatchBrush Class</h1>
<p>Creates a <strong>HatchBrush</strong> object based on a hatch style, a foreground color, and a background color.</p>
<p><strong>Inherits from</strong>: CGpBrush.<br> <strong>Include file</strong>: CGpBrush.inc.</p>
<h3 id="methods-2">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ConstructorHatchBrush">Constructors</a></td>
<td>Creates a <strong>HatchBrush</strong> object based on a hatch style, a foreground color, and a background color.</td>
</tr>
<tr class="even">
<td><a href="#GetBackgroundColor">GetBackgroundColor</a></td>
<td>Gets the background color of this hatch brush.</td>
</tr>
<tr class="odd">
<td><a href="#GetForegroundColor">GetForegroundColor</a></td>
<td>Gets the foreground color of this hatch brush.</td>
</tr>
<tr class="even">
<td><a href="#GetHatchStyle">GetHatchStyle</a></td>
<td>Gets the hatch style of this hatch brush.</td>
</tr>
</tbody>
</table>
<h1 id="cgplineargradientbrush-class">CGpLinearGradientBrush Class</h1>
<p>Defines a brush that paints a color gradient in which the color changes evenly from the starting boundary line of the linear gradient brush to the ending boundary line of the linear gradient brush. The boundary lines of a linear gradient brush are two parallel straight lines. The color gradient is perpendicular to the boundary lines of the linear gradient brush, changing gradually across the stroke from the starting boundary line to the ending boundary line. The color gradient has one color at the starting boundary line and another color at the ending boundary line.</p>
<p><strong>Inherits from</strong>: CGpBrush.<br> <strong>Include file</strong>: CGpBrush.inc.</p>
<h3 id="constructors-and-methods">Constructors and Methods</h3>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ConstructorsLGBrush">Constructorss</a></td>
<td>Creates a <strong>LinearGradientBrush</strong> object.</td>
</tr>
<tr class="even">
<td><a href="#GetBlendLGBrush">GetBlend</a></td>
<td>Gets the blend factors and their corresponding blend positions.</td>
</tr>
<tr class="odd">
<td><a href="#GetBlendCountLGBrush">GetBlendCount</a></td>
<td>Gets the number of blend factors currently set.</td>
</tr>
<tr class="even">
<td><a href="#GetGammaCorrectionLGBrush">GetGammaCorrection</a></td>
<td>Determines whether gamma correction is enabled for this brush.</td>
</tr>
<tr class="odd">
<td><a href="#GetInterpolationColorCountLGBrush">GetInterpolationColorCount</a></td>
<td>Gets the number of colors currently set to be interpolated.</td>
</tr>
<tr class="even">
<td><a href="#GetInterpolationColorsLGBrush">GetInterpolationColors</a></td>
<td>Gets the blend factors and their corresponding blend positions.</td>
</tr>
<tr class="odd">
<td><a href="#GetLinearColors">GetLinearColors</a></td>
<td>Gets the starting color and ending color.</td>
</tr>
<tr class="even">
<td><a href="#GetRectangleLGBrush">GetRectangle</a></td>
<td>Gets the rectangle that defines the boundaries of the gradient.</td>
</tr>
<tr class="odd">
<td><a href="#GetTransformLGBrush">GetTransform</a></td>
<td>Gets the transformation matrix.</td>
</tr>
<tr class="even">
<td><a href="#GetWrapModeLGBrush">GetWrapMode</a></td>
<td>Gets the wrap mode currently set for this brush.</td>
</tr>
<tr class="odd">
<td><a href="#MultiplyTransformLGBrush">MultiplyTransform</a></td>
<td>Updates this brush's transformation matrix with the product of itself and another matrix.</td>
</tr>
<tr class="even">
<td><a href="#ResetTransformLGBrush">ResetTransform</a></td>
<td>Resets the transformation matrix to the identity matrix.</td>
</tr>
<tr class="odd">
<td><a href="#RotateTransformLGBrush">RotateTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a rotation matrix.</td>
</tr>
<tr class="even">
<td><a href="#ScaleTransformLGBrush">ScaleTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a scaling matrix.</td>
</tr>
<tr class="odd">
<td><a href="#SetBlendLGBrush">SetBlend</a></td>
<td>Sets the blend factors and the blend positions to create a custom blend.</td>
</tr>
<tr class="even">
<td><a href="#SetBlendBellShapeLGBrush">SetBlendBellShape</a></td>
<td>Sets the blend bell shape.</td>
</tr>
<tr class="odd">
<td><a href="#SetBlendTriangularShapeLGBrush">SetBlendTriangularShape</a></td>
<td>Sets the blend triangular shape.</td>
</tr>
<tr class="even">
<td><a href="#SetGammaCorrectionLGBrush">SetGammaCorrection</a></td>
<td>Specifies whether gamma correction is enabled.</td>
</tr>
<tr class="odd">
<td><a href="#SetInterpolationColorsLGBrush">SetInterpolationColors</a></td>
<td>Sets the colors to be interpolated and their corresponding blend positions.</td>
</tr>
<tr class="even">
<td><a href="#SetLinearColors">SetLinearColors</a></td>
<td>Sets the starting color and ending color.</td>
</tr>
<tr class="odd">
<td><a href="#SetTransformLGBrush">SetTransform</a></td>
<td>Sets the transformation matrix.</td>
</tr>
<tr class="even">
<td><a href="#SetWrapModeLGBrush">SetWrapMode</a></td>
<td>Sets the wrap mode.</td>
</tr>
<tr class="odd">
<td><a href="#TranslateTransformLGBrush">TranslateTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a translation matrix.</td>
</tr>
</tbody>
</table>
<h1 id="cgppathgradientbrush-class">CGpPathGradientBrush Class</h1>
<p>A <strong>PathGradientBrush</strong> object stores the attributes of a color gradient that you can use to fill the interior of a path with a gradually changing color. A path gradient brush has a boundary path, a boundary color, a center point, and a center color. When you paint an area with a path gradient brush, the color changes gradually from the boundary color to the center color as you move from the boundary path to the center point.</p>
<p><strong>Inherits from</strong>: CGpBrush.<br> <strong>Include file</strong>: CGpBrush.inc.</p>
<h3 id="constructors-and-methods-1">Constructors and Methods</h3>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ConstructorsPGBrush">Constructors</a></td>
<td>Creates a <strong>PathGradientBrush</strong> object.</td>
</tr>
<tr class="even">
<td><a href="#GetBlendPGBrush">GetBlend</a></td>
<td>Gets the blend factors and their corresponding blend positions.</td>
</tr>
<tr class="odd">
<td><a href="#GetBlendCountPGBrush">GetBlendCount</a></td>
<td>Gets the number of blend factors currently set.</td>
</tr>
<tr class="even">
<td><a href="#GetCenterColor">GetCenterColor</a></td>
<td>Gets center color of the brush.</td>
</tr>
<tr class="odd">
<td><a href="#GetCenterPoint">GetCenterPoint</a></td>
<td>Gets the center point of the brush.</td>
</tr>
<tr class="even">
<td><a href="#GetFocusScales">GetFocusScales</a></td>
<td>Gets the focus scales of the brush.</td>
</tr>
<tr class="odd">
<td><a href="#GetGammaCorrectionPGBrush">GetGammaCorrection</a></td>
<td>Determines whether gamma correction is enabled for this brush.</td>
</tr>
<tr class="even">
<td><a href="#GetInterpolationColorCountPGBrush">GetInterpolationColorCount</a></td>
<td>Gets the number of preset colors currently specified for this brush.</td>
</tr>
<tr class="odd">
<td><a href="#GetInterpolationColorsPGBrush">GetInterpolationColors</a></td>
<td>Gets preset colors and blend positions currently specified for this brush.</td>
</tr>
<tr class="even">
<td><a href="#GetPointCount">GetPointCount</a></td>
<td>Gets the number of points in the array of points that defines this brush's boundary path.</td>
</tr>
<tr class="odd">
<td><a href="#GetRectanglePGBrush">GetRectangle</a></td>
<td>Gets the smallest rectangle that encloses the boundary path of this brush.</td>
</tr>
<tr class="even">
<td><a href="#GetSurroundColorCount">GetSurroundColorCount</a></td>
<td>Gets the number of colors that have been specified for the boundary path of this brush.</td>
</tr>
<tr class="odd">
<td><a href="#GetSurroundColors">GetSurroundColors</a></td>
<td>Gets the surround colors currently specified for this brush.</td>
</tr>
<tr class="even">
<td><a href="#GetTransformPGBrush">GetTransform</a></td>
<td>Gets the transformation matrix.</td>
</tr>
<tr class="odd">
<td><a href="#GetWrapModePGBrush">GetWrapMode</a></td>
<td>Gets the wrap mode currently set for this brush.</td>
</tr>
<tr class="even">
<td><a href="#MultiplyTransformPGBrush">MultiplyTransform</a></td>
<td>Updates this brush's transformation matrix with the product of itself and another matrix.</td>
</tr>
<tr class="odd">
<td><a href="#ResetTransformPGBrush">ResetTransform</a></td>
<td>Resets the transformation matrix to the identity matrix.</td>
</tr>
<tr class="even">
<td><a href="#RotateTransformPGBrush">RotateTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a rotation matrix.</td>
</tr>
<tr class="odd">
<td><a href="#ScaleTransformPGBrush">ScaleTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a scaling matrix.</td>
</tr>
<tr class="even">
<td><a href="#SetBlendPGBrush">SetBlend</a></td>
<td>Sets the blend factors and the blend positions to create a custom blend.</td>
</tr>
<tr class="odd">
<td><a href="#SetBlendBellShapePGBrush">SetBlendBellShape</a></td>
<td>Sets the blend bell shape.</td>
</tr>
<tr class="even">
<td><a href="#SetBlendTriangularShapePGBrush">SetBlendTriangularShape</a></td>
<td>Sets the blend triangular shape.</td>
</tr>
<tr class="odd">
<td><a href="#SetCenterColor">SetCenterColor</a></td>
<td>Sets the center color of this brush.</td>
</tr>
<tr class="even">
<td><a href="#SetCenterPoint">SetCenterPoint</a></td>
<td>Sets the center point of this brush.</td>
</tr>
<tr class="odd">
<td><a href="#SetFocusScales">SetFocusScales</a></td>
<td>Sets the focus scales of this brush.</td>
</tr>
<tr class="even">
<td><a href="#SetGammaCorrectionPGBrush">SetGammaCorrection</a></td>
<td>Specifies whether gamma correction is enabled.</td>
</tr>
<tr class="odd">
<td><a href="#SetInterpolationColorsPGBrush">SetInterpolationColors</a></td>
<td>Sets the colors to be interpolated and their corresponding blend positions.</td>
</tr>
<tr class="even">
<td><a href="#SetSurroundColors">SetSurroundColors</a></td>
<td>Sets the surround colors of this brush.</td>
</tr>
<tr class="odd">
<td><a href="#SetTransformPGBrush">SetTransform</a></td>
<td>Sets the transformation matrix.</td>
</tr>
<tr class="even">
<td><a href="#SetWrapModePGBrush">SetWrapMode</a></td>
<td>Sets the wrap mode.</td>
</tr>
<tr class="odd">
<td><a href="#TranslateTransformPGBrush">TranslateTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a translation matrix.</td>
</tr>
</tbody>
</table>
<h1 id="cgptexturebrush-class">CGpTextureBrush Class</h1>
<p>Defines a <strong>Brush</strong> object that contains an <strong>Image</strong> object that is used for the fill. The fill image can be transformed by using the local <strong>Matrix</strong> object contained in the <strong>Brush</strong> object.</p>
<p><strong>Inherits from</strong>: CGpBrush.<br> <strong>Include file</strong>: CGpBrush.inc.</p>
<h3 id="constructors-and-methods-2">Constructors and Methods</h3>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ConstructorsTBrush">Constructors</a></td>
<td>Creates a texture brush.</td>
</tr>
<tr class="even">
<td><a href="#GetImage">GetImage</a></td>
<td>Gets a pointer to the <strong>Image</strong> object that is defined by this brush.</td>
</tr>
<tr class="odd">
<td><a href="#GetTransformTBrush">GetTransform</a></td>
<td>Gets the transformation matrix.</td>
</tr>
<tr class="even">
<td><a href="#GetWrapModeTBrush">GetWrapMode</a></td>
<td>Gets the wrap mode currently set for this brush.</td>
</tr>
<tr class="odd">
<td><a href="#MultiplyTransformTBrush">MultiplyTransform</a></td>
<td>Updates this brush's transformation matrix with the product of itself and another matrix.</td>
</tr>
<tr class="even">
<td><a href="#ResetTransformTBrush">ResetTransform</a></td>
<td>Resets the transformation matrix to the identity matrix.</td>
</tr>
<tr class="odd">
<td><a href="#RotateTransformTBrush">RotateTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a rotation matrix.</td>
</tr>
<tr class="even">
<td><a href="#ScaleTransformTBrush">ScaleTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a scaling matrix.</td>
</tr>
<tr class="odd">
<td><a href="#SetTransformTBrush">SetTransform</a></td>
<td>Sets the transformation matrix.</td>
</tr>
<tr class="even">
<td><a href="#SetWrapModeTBrush">SetWrapMode</a></td>
<td>Sets the wrap mode.</td>
</tr>
<tr class="odd">
<td><a href="#TranslateTransformTBrush">TranslateTransform</a></td>
<td>Updates this brush's current transformation matrix with the product of itself and a translation matrix.</td>
</tr>
</tbody>
</table>
<h1 id="constructors-(cgpbrush)"><a name="ConstructorsBrush"></a>Constructors (CGpBrush)</h1>
<p>Creates a <strong>Brush</strong> object.</p>
<pre><code>CONSTRUCTOR CGpBrush
CONSTRUCTOR CGpBrush (BYVAL pBrush AS CGpBrush PTR)
</code></pre>
<h1 id="clone-(cgpbrush)"><a name="CloneBrush"></a>Clone (CGpBrush)</h1>
<p>Copies the contents of the existing <strong>Brush</strong> object into a new <strong>Brush</strong> object.</p>
<pre><code>FUNCTION Clone (BYVAL pBrush AS CGpBrush PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pBrush</em></td>
<td>Pointer to a variable that will receive a pointer to the cloned <strong>Brush</strong> object.</td>
</tr>
</tbody>
</table>
<h4 id="return-value">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a SolidBrush object, clones it, and then uses the clone
' to fill a rectangle.
' ========================================================================================
SUB Example_CloneBrush (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, rxRatio)

   ' // Create a SolidBrush object
   DIM solidBrush AS CGpSolidBrush = GDIP_ARGB(255, 255, 0, 0)

   ' // Create a clone of solidBrush
   DIM cloneBrush AS CGpSolidBrush
   solidBrush.Clone(@cloneBrush)
   ' // You can also use:
   ' DIM cloneBrush AS CGpSolidBrush = @solidBrush

   ' // Use cloneBrush to fill a rectangle
   graphics.FillRectangle(@cloneBrush, 0, 0, 100, 100)

END SUB
' ========================================================================================
</code></pre>
<h1 id="gettype-(cgpbrush)"><a name="GetTypeBrush"></a>GetType (CGpBrush)</h1>
<p>Gets the type of this brush.</p>
<pre><code>FUNCTION GetType () AS GpBrushType
</code></pre>
<h4 id="return-value-1">Return value</h4>
<p>This method returns the type of this brush. The value returned is one of the elements of the <strong>BrushType</strong> enumeration.</p>
<h4 id="example-1">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a SolidBrush object, checks the type of the object, and
' then, if the type is BrushTypeSolidColor, uses the brush to fill a rectangle.
' ========================================================================================
SUB Example_GetType (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a SolidBrush object
   DIM solidBrush AS CGpSolidBrush = GDIP_ARGB(255, 0, 0, 255)

   ' // Get the type of solidBrush
   DIM nType AS BrushType = solidBrush.GetType

   ' // If the type of solidBrush is BrushTypeSolidColor, use it to fill a rectangle
   IF nType = BrushTypeSolidColor THEN
      graphics.FillRectangle(@solidBrush, 0, 0, 100, 100)
   END IF

END SUB
' ========================================================================================
</code></pre>
<h1 id="constructors-(cgpsolidbrush)"><a name="ConstructorSolidBrush"></a>Constructors (CGpSolidBrush)</h1>
<p>Creates a <strong>SolidBrush</strong> object based on a color.</p>
<pre><code>CONSTRUCTOR CGpSolidBrush (BYVAL pSolidBrush AS CGpSolidBrush PTR)
CONSTRUCTOR CGpSolidBrush (BYVAL colour AS ARGB = &amp;hFF000000)
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colour</em></td>
<td>An ARGB color that specifies the initial color of this solid brush.</td>
</tr>
</tbody>
</table>
<h1 id="getcolor-(cgpsolidbrush)"><a name="GetColorSolidBrush"></a>GetColor (CGpSolidBrush)</h1>
<p>Gets the color of this solid brush.</p>
<pre><code>FUNCTION GetColor (BYVAL colour AS ARGB PTR) AS GpStatus
FUNCTION GetColor () AS ARGB
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colour</em></td>
<td>Pointer to a variable that receives the color of this solid brush.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-2">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<p>The second overloaded function returns the ARGB color as the result of the function.</p>
<h1 id="setcolor-(cgpsolidbrush)"><a name="SetColorSolidBrush"></a>SetColor (CGpSolidBrush)</h1>
<p>Sets the color of this solid brush.</p>
<pre><code>FUNCTION SetColor (BYVAL colour AS ARGB) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colour</em></td>
<td>The color to be set in this solid brush.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-3">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-2">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a solid brush and uses it to fill a rectangle. The code
' uses GdipSetSolidFillColor to change the color of the solid brush and then paints a
' second rectangle the new color.
' ========================================================================================
SUB Example_SetColor (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, rxRatio)

   ' // Create a solid brush, and use it to fill a rectangle
   DIM solidBrush AS CGpSolidBrush = GDIP_ARGB(255, 0, 0, 255)
   graphics.FillRectangle(@solidBrush, 10, 10, 200, 100)

   ' // Change the color of the brush to red, and fill another rectangle
   solidBrush.SetColor(GDIP_ARGB(255, 255, 0, 0))
   graphics.FillRectangle(@solidBrush, 220, 10, 200, 100)

END SUB
' ========================================================================================
</code></pre>
<h1 id="constructors-(cgphatchbrush)"><a name="ConstructorHatchBrush"></a>Constructors (CGpHatchBrush)</h1>
<p>Creates a <strong>HatchBrush</strong> object based on a hatch style, a foreground color, and a background color.</p>
<pre><code>CONSTRUCTOR CGpHatchBrush (BYVAL pHatchBrush AS CGpHatchBrush PTR)
FUNCTION HatchBrush (BYVAL hatchStyle AS HatchStyle, BYVAL foreColor AS ARGB, _
   BYVAL backColor AS ARGB = &amp;HFF000000)
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>hatchStyle</em></td>
<td>Element of the <strong>HatchStyle</strong> enumeration that specifies the pattern of hatch lines that will be used.</td>
</tr>
<tr class="even">
<td><em>foreColor</em></td>
<td>Reference to a color to use for the hatch lines.</td>
</tr>
<tr class="odd">
<td><em>backColor</em></td>
<td>Optional. Reference to a color to use for the background.</td>
</tr>
</tbody>
</table>
<h1 id="getbackgroundcolor-(cgphatchbrush)"><a name="GetBackgroundColor"></a>GetBackgroundColor (CGpHatchBrush)</h1>
<p>Gets the background color of this hatch brush.</p>
<pre><code>FUNCTION GetBackgroundColor (BYVAL colour AS ARGB PTR) AS GpStatus
FUNCTION GetBackgroundColor () AS ARGB
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colour</em></td>
<td>Pointer to a variable that receives the background color. The background color defines the color over which the hatch lines are drawn.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-4">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<p>The second overloaded function returns the ARGB color as the result of the function.</p>
<h4 id="example-3">Example</h4>
<pre><code>' ========================================================================================
' The following example sets up three Color objects: black, turquoise, and current
' (initialized to black). A rectangle is painted by using turquoise as the background
' color and black as the foreground color. Then the HatchBrush.GetBackgroundColor method
' is used to get the current color of the brush (which at the time is turquoise). The
' address of the current Color object (initialized to black) is passed as the return point
' for the call to HatchBrush,GetBackgroundColor. When the rectangle is painted again,
' note that the background color is again turquoise (not black). This shows that the call
' to HatchBrush.GetBackgroundColor was successful.
' ========================================================================================
SUB Example_HatchBrushGetBackgroundColor (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, rxRatio)

   ' // Set colors
   DIM black AS ARGB = GDIP_ARGB(255, 0, 0, 0)           ' // foreground
   DIM turquoise AS ARGB = GDIP_ARGB(255, 0, 255, 255)   ' // background
   DIM current AS ARGB = GDIP_ARGB(255, 0, 0, 0)         ' // new foreground

   ' // Set and then draw the first hatch style.
   DIM brush AS CGpHatchBrush = CGpHatchBrush(HatchStyleHorizontal, black, turquoise)
   graphics.FillRectangle(@brush, 20, 20, 100, 50)

   ' // Get the current background color of the brush.
   brush.GetBackgroundColor(@current)

   ' // Draw the rectangle again using the current color.
   DIM brush2 AS CGpHatchBrush = CGpHatchBrush(HatchStyleDiagonalCross, black, current)
   graphics.FillRectangle(@brush2, 130, 20, 100, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="getforegroundcolor-(cgphatchbrush)"><a name="GetForegroundColor"></a>GetForegroundColor (CGpHatchBrush)</h1>
<p>Gets the foreground color of this hatch brush.</p>
<pre><code>FUNCTION GetForegroundColor (BYVAL colour AS ARGB PTR) AS GpStatus
FUNCTION GetForegroundColor () AS ARGB
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colour</em></td>
<td>Pointer to a variable that receives the foreground color. The foreground color defines the color of the hatch lines.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-5">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<p>The second overloaded function returns the ARGB color as the result of the function.</p>
<h4 id="example-4">Example</h4>
<pre><code>' ========================================================================================
' The following example sets up three Color objects: black, turquoise, and current
' (initialized to black). A rectangle is painted by using turquoise as the background
' color and black as the foreground color. Then the HatchBrush.GetBackgroundColor method
' is used to get the current color of the brush (which at the time is turquoise). The
' address of the current Color object (initialized to black) is passed as the return point
' for the call to HatchBrush,GetBackgroundColor. When the rectangle is painted again,
' note that the background color is again turquoise (not black). This shows that the call
' to HatchBrush.GetBackgroundColor was successful.
' ========================================================================================
SUB Example_HatchBrushGetForegroundColor (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, rxRatio)

   ' // Set colors
   DIM blue AS ARGB = GDIP_ARGB(255, 0, 0, 255)          ' // foreground
   DIM turquoise AS ARGB = GDIP_ARGB(255, 0, 255, 255)   ' // background
   DIM current AS ARGB = GDIP_ARGB(255, 0, 0, 0)         ' // new foreground

   ' // Set and then draw the first hatch style.
   DIM brush AS CGpHatchBrush = CGpHatchBrush(HatchStyleHorizontal, blue, turquoise)
   graphics.FillRectangle(@brush, 20, 20, 100, 50)

   ' // Get the current foreground color of the brush.
   brush.GetForegroundColor(@current)

   ' // Draw the rectangle again using the current color.
   DIM brush2 AS CGpHatchBrush = CGpHatchBrush(HatchStyleDiagonalCross, current, turquoise)
   graphics.FillRectangle(@brush2, 130, 20, 100, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="gethatchstyle-(cgphatchbrush)"><a name="GetHatchStyle"></a>GetHatchStyle (CGpHatchBrush)</h1>
<p>Gets the hatch style of this hatch brush.</p>
<pre><code>FUNCTION GetHatchStyle () AS HatchStyle
</code></pre>
<h4 id="return-value-6">Return value</h4>
<p>This method returns the hatch style, which is one of the elements of the <strong>HatchStyle</strong> enumeration.</p>
<h4 id="example-5">Example</h4>
<pre><code>' ========================================================================================
' The following example sets up two hatch styles: horiz and current (initialized to
' HatchStyleDiagonalCross). A rectangle that uses horiz as the hatch style is painted.
' Then the HatchBrush.GetHatchStyle method is used to get the current hatch style of the
' brush (which at the time is HatchStyleHorizontal). The address of the current HatchStyle
' object (initialized to HatchStyleDiagonalCross) is passed as the return point for the
' call to GetHatchStyle. When the rectangle is painted again, notice that the hatch style
' is again HatchStyleHorizontal (not HatchStyleDiagonalCross). This shows that the call to
' HatchBrush.GetHatchStyle was successful. 
' ========================================================================================
SUB Example_HatchBrushGetHatchStyle (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Set colors
   DIM blue AS ARGB = GDIP_ARGB(255, 0, 0, 255)          ' // foreground
   DIM turquoise AS ARGB = GDIP_ARGB(255, 0, 255, 255)   ' // background

   ' // Set hatch styles
   DIM horiz AS HatchStyle = HatchStyleHorizontal
   DIM current AS HatchStyle = HatchStyleDiagonalCross

   ' // Set and then draw the first hatch style.
   DIM brush AS CGpHatchBrush = CGpHatchBrush(horiz, blue, turquoise)
   graphics.FillRectangle(@brush, 20, 20, 100, 50)

   ' // Get the current hatch style of the brush.
   current = brush.GetHatchStyle
   
   ' // Get the current background color of the brush.
   brush.GetBackgroundColor(@current)

   ' // Draw the rectangle again using the current hatch style.
   DIM brush2 AS CGpHatchBrush = CGpHatchBrush(current, blue, turquoise)
   graphics.FillRectangle(@brush2, 130, 20, 100, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="constructors-(cgplineargradientbrush)"><a name="ConstructorsLGBrush"></a>Constructors (CGpLinearGradientBrush)</h1>
<p>Creates a <strong>LinearGradientBrush</strong> object from a set of boundary points and boundary colors.</p>
<pre><code>CONSTRUCTOR CGpLinearGradientBrush (BYVAL pLinearGradientBrush AS CGpLinearGradientBrush PTR)
CONSTRUCTOR CGpLinearGradientBrush (BYVAL point1 AS GpPointF PTR, BYVAL point2 AS GpPointF PTR, _
   BYVAL color1 AS ARGB, BYVAL color2 AS ARGB)
CONSTRUCTOR CGpLinearGradientBrush (BYVAL point1 AS GpPoint PTR, BYVAL point2 AS GpPoint PTR, _
   BYVAL color1 AS ARGB, BYVAL color2 AS ARGB)
</code></pre>
<p>Creates a <strong>LinearGradientBrush</strong> object based on a rectangle and mode of direction.</p>
<pre><code>CONSTRUCTOR CGpLinearGradientBrush (BYVAL rc AS GpRectF PTR, BYVAL color1 AS ARGB, _
   BYVAL color2 AS ARGB, BYVAL mode AS LinearGradientMode)
CONSTRUCTOR CGpLinearGradientBrush (BYVAL rc AS GpRect PTR, BYVAL color1 AS ARGB, _
   BYVAL color2 AS ARGB, BYVAL mode AS LinearGradientMode)
</code></pre>
<p>Creates a LinearGradientBrush object from a rectangle and angle of direction.</p>
<pre><code>CONSTRUCTOR CGpLinearGradientBrush (BYVAL rc AS GpRectF PTR, BYVAL color1 AS ARGB, _
   BYVAL color2 AS ARGB, BYVAL angle AS SINGLE, BYVAL isAngleScalable AS BOOL)
CONSTRUCTOR CGpLinearGradientBrush (BYVAL rc AS GpRect PTR, BYVAL color1 AS ARGB, _
   BYVAL color2 AS ARGB, BYVAL angle AS SINGLE, BYVAL isAngleScalable AS BOOL)
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>point1</em></td>
<td>Reference to a <strong>GpPoint</strong> structure that specifies the starting point of the gradient. The starting boundary line passes through the starting point.</td>
</tr>
<tr class="even">
<td><em>point2</em></td>
<td>Reference to a <strong>GpPoint</strong> structure that specifies the ending point of the gradient. The ending boundary line passes through the ending point.</td>
</tr>
<tr class="odd">
<td><em>color1</em></td>
<td>An ARGB value that specifies the color at the starting boundary line of this linear gradient brush.</td>
</tr>
<tr class="even">
<td><em>color2</em></td>
<td>An ARGB value that specifies the color at the ending boundary line of this linear gradient brush.</td>
</tr>
<tr class="odd">
<td><em>rc</em></td>
<td>Reference to a rectangle that specifies the starting and ending points of the gradient. The upper-left corner of the rectangle is the starting point. The lower-right corner is the ending point.</td>
</tr>
<tr class="even">
<td><em>mode</em></td>
<td>Element of the <strong>LinearGradientMode</strong> enumeration that specifies the direction of the gradient.</td>
</tr>
<tr class="odd">
<td><em>angle</em></td>
<td>Real number that, if <em>isAngleScalable</em> is TRUE, specifies the base angle from which the angle of the directional line is calculated, or that, if <em>isAngleScalable</em> is FALSE, specifies the angle of the directional line. The angle is measured from the top of the rectangle that is specified by rect and must be in degrees. The gradient follows the directional line.</td>
</tr>
<tr class="even">
<td><em>isAngleScalable</em></td>
<td>BOOL value that specifies whether the angle is scalable. If <em>isAngleScalable</em> is TRUE, the angle of the directional line is scalable; otherwise, the angle is not scalable.</td>
</tr>
</tbody>
</table>
<h1 id="getblend-(cgplineargradientbrush)"><a name="GetBlendLGBrush"></a>GetBlend (CGpLinearGradientBrush)</h1>
<p>Gets the blend factors and their corresponding blend positions from a <strong>LinearGradientBrush</strong> object.</p>
<pre><code>FUNCTION GetBlend (BYVAL blendFactors AS SINGLE PTR, BYVAL blendPositions AS SINGLE PTR, _
   BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>blendFactors</em></td>
<td>Pointer to an array that receives the blend factors. Each number in the array indicates a percentage of the ending color and is in the range from 0.0 through 1.0.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array that receives the blend positions. Each number in the array indicates a percentage of the distance between the starting boundary and the ending boundary and is in the range from 0.0 through 1.0, where 0.0 indicates the starting boundary of the gradient and 1.0 indicates the ending boundary. A blend position between 0.0 and 1.0 indicates a line, parallel to the boundary lines, that is a certain fraction of the distance from the starting boundary to the ending boundary. For example, a blend position of 0.7 indicates the line that is 70 percent of the distance from the starting boundary to the ending boundary. The color is constant on lines that are parallel to the boundary lines.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Integer that specifies the number of blend factors to retrieve. Before calling the <strong>GetBlend</strong> method of a <strong>LinearGradientBrush</strong> object, call the <strong>GetBlendCount</strong> method of that same <strong>LinearGradientBrush</strong> object to determine the current number of blend factors. The number of blend positions retrieved is the same as the number of blend factors retrieved.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-7">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks">Remarks</h4>
<p>A <strong>LinearGradientBrush</strong> object has two parallel boundaries: a starting boundary and an ending boundary. A color is associated with each of these two boundaries. Each boundary is a straight line that passes through a specified point — the starting boundary passes through the starting point; the ending boundary passes through the ending point — and is perpendicular to the direction of the linear gradient brush. The direction of the linear gradient brush follows the line that is defined by the starting and ending points. This line, the &quot;directional line,&quot; may be horizontal, vertical, or diagonal. All points that lie on a line that is parallel to the boundaries are the same color. When you fill an area with a linear gradient brush, the color changes gradually from one line to the next as you move along the directional line from the starting boundary to the ending boundary. By default, the change in color is proportional to the change in distance; that is, a line 30 percent of the distance between the starting boundary and the ending boundary has a color that is 30 percent of the distance between the starting boundary color and the ending boundary color. The color pattern is repeated outside of the starting and ending boundaries.</p>
<p>You can call the <strong>SetBlend</strong> method of a LinearGradientBrush object to customize the relationship between color and distance. For example, suppose you set the blend positions to {0, 0.5, 1} and you set the blend factors to {0, 0.3, 1}. Then a line 50 percent of the distance between the starting boundary and the ending boundary will have a color that is 30 percent of the distance between the starting boundary color and the ending boundary color.</p>
<h4 id="example-6">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush, sets its blend, and uses the brush
' to fill a rectangle. The code then gets the blend. The blend factors and positions can
' then be inspected or used in some way.
' ========================================================================================
SUB Example_GetBlend (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM factors(0 TO 3) AS SINGLE = {0.0, 0.4, 0.6, 1.0}
   DIM positions(0 TO 3) AS SINGLE = {0.0, 0.2, 0.8, 1.0}
   DIM rcf AS GpRectF = GDIP_RECTF(0, 0, 100, 50)

   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rcf, GDIP_ARGB(255, 255, 0, 0), _
       GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   linGrBrush.SetBlend(@factors(0), @positions(0), 4)
   graphics.FillRectangle(@linGrBrush, @rcf)

   DIM blendCount AS LONG = linGrBrush.GetBlendCount
   DIM rgFactors(blendCount - 1) AS SINGLE
   DIM rgPositions(blendCount - 1) AS SINGLE

   linGrBrush.GetBlend(@rgFactors(0), @rgPositions(0), blendCount)

   FOR j AS LONG = 0 TO blendCount - 1
'      // Inspect or use the value in rgFactors(j)
'      // Inspect or use the value in rgPositions(j)
      OutputDebugString STR(rgFactors(j)) &amp; STR(rgPositions(j))
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getblendcount-(cgplineargradientbrush)"><a name="GetBlendCountLGBrush"></a>GetBlendCount (CGpLinearGradientBrush)</h1>
<p>Gets the number of blend factors currently set for this <strong>LinearGradientBrush</strong> object.</p>
<pre><code>FUNCTION GetBlendCount () AS INT_
</code></pre>
<h4 id="return-value-8">Return value</h4>
<p>This method returns the number of blend factors currently set for this <strong>LinearGradientBrush</strong> object. If no custom blend has been set by using <strong>SetBlend</strong>, or if invalid positions were passed to <strong>SetBlend</strong>, then <strong>GetBlend</strong> returns 1.</p>
<h4 id="example-7">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush, sets its blend, and uses the brush
' to fill a rectangle. The code then gets the blend. The blend factors and positions can
' then be inspected or used in some way.
' ========================================================================================
SUB Example_GetBlend (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM factors(0 TO 3) AS SINGLE = {0.0, 0.4, 0.6, 1.0}
   DIM positions(0 TO 3) AS SINGLE = {0.0, 0.2, 0.8, 1.0}

   DIM pt1 AS GpPoint = GDIP_POINT(0, 0)
   DIM pt2 AS GpPoint = GDIP_POINT(100, 0)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, _
      GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255))
   linGrBrush.SetBlend(@factors(0), @positions(0), 4)

   ' // Use the linear gradient brush to fill a rectangle.
   graphics.FillRectangle(@linGrBrush, 0, 0, 100, 50)

   ' // Obtain information about the linear gradient brush.
   DIM blendCount AS LONG = linGrBrush.GetBlendCount
   DIM rgFactors(blendCount - 1) AS SINGLE
   DIM rgPositions(blendCount - 1) AS SINGLE

   linGrBrush.GetBlend(@rgFactors(0), @rgPositions(0), blendCount)

   FOR j AS LONG = 0 TO blendCount - 1
'      // Inspect or use the value in rgFactors(j)
'      // Inspect or use the value in rgPositions(j)
      OutputDebugString STR(rgFactors(j)) &amp; STR(rgPositions(j))
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getgammacorrection-(cgplineargradientbrush)"><a name="GetGammaCorrectionLGBrush"></a>GetGammaCorrection (CGpLinearGradientBrush)</h1>
<p>Gets the focus scales of this path gradient brush.</p>
<pre><code>FUNCTION GetGammaCorrection () AS BOOL
</code></pre>
<h4 id="return-value-9">Return value</h4>
<p>If gamma correction is enabled, this method returns TRUE; otherwise, it returns FALSE.</p>
<h1 id="getinterpolationcolorcount-(cgplineargradientbrush)"><a name="GetInterpolationColorCountLGBrush"></a>GetInterpolationColorCount (CGpLinearGradientBrush)</h1>
<p>Gets the number of colors currently set to be interpolated for this linear gradient brush.</p>
<pre><code>FUNCTION GetInterpolationColorCount () AS INT_
</code></pre>
<h4 id="return-value-10">Return value</h4>
<p>This method returns the number of colors to be interpolated for this linear gradient brush. If no colors have been set by using <strong>SetInterpolationColors</strong>, or if invalid positions were passed to <strong>SetInterpolationColors</strong>, then <strong>GetInterpolationColorCount</strong> returns 0.</p>
<h4 id="remarks-1">Remarks</h4>
<p>A simple linear gradient brush has two colors: a color at the starting boundary and a color at the ending boundary. When you paint with such a brush, the color changes gradually from the starting color to the ending color as you move from the starting boundary to the ending boundary. You can create a more complex gradient by using the <strong>SetInterpolationColors</strong> method to specify an array of colors and their corresponding blend positions to be interpolated for this linear gradient brush.</p>
<p>You can obtain the colors and blend positions currently set for a linear gradient brush by calling its <strong>GetInterpolationColors</strong> method. Before you call the <strong>GetInterpolationColors</strong> method, you must allocate two buffers: one to hold the array of colors and one to hold the array of blend positions. You can call the <strong>GetInterpolationColorCount</strong> method to determine the required size of those buffers. The size of the colors buffer is the return value of <strong>GetInterpolationColorCount</strong> multiplied by <strong>sizeof(Color)</strong>. The size of the blend positions buffer is the value of <strong>GetInterpolationColorCount</strong> multiplied by <strong>sizeof(REAL)</strong>.</p>
<h4 id="example-8">Example</h4>
<pre><code>' ========================================================================================
' The following example sets the colors that are interpolated for this linear gradient
' brush to red, blue, and green and sets the blend positions to 0, 0.3, and 1. The code
' calls the LinearGradientBrush::GetInterpolationColorCount method of a LinearGradientBrush
' object to obtain the number of colors currently set to be interpolated for the brush.
' Next, the code gets the colors and their positions. Then, the code fills a small
' rectangle with each color.
' ========================================================================================
SUB Example_GetInterpolationColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush, and set the colors to be interpolated.
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 0)}
   DIM positions(0 TO 2) AS SINGLE = {0.0, 0.3, 1.0}

   DIM pt1 AS GpPoint = GDIP_POINT(0, 0)
   DIM pt2 AS GpPoint = GDIP_POINT(100, 0)

   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 255, 255, 255))
   linGrBrush.SetInterpolationColors(@colors(0), @positions(0), 3)

   ' // Obtain information about the linear gradient brush.
   ' // How many colors have been specified to be interpolated for this brush?
   DIM colorCount AS LONG = linGrBrush.GetInterpolationColorCount

   ' // Allocate a buffer large enough to hold the set of colors.
   DIM rgcolors(0 TO colorCount - 1) AS ARGB

   ' // Allocate a buffer to hold the relative positions of the colors.
   DIM rgPositions(0 TO colorCount - 1) AS SINGLE

   ' // Get the colors and their relative positions.
   linGrBrush.GetInterpolationColors(@rgcolors(0), @rgPositions(0), colorCount)

   ' // Fill a small rectangle with each of the colors.
   DIM pSolidBrush AS CGpSolidBrush PTR
   FOR j AS LONG = 0 TO colorCount - 1
      pSolidBrush = NEW CGpSolidBrush(rgcolors(j))
      graphics.FillRectangle(pSolidBrush, 15 * j, 0, 10, 10)
      Delete pSolidBrush
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getinterpolationcolors-(cgplineargradientbrush)"><a name="GetInterpolationColorsLGBrush"></a>GetInterpolationColors (CGpLinearGradientBrush)</h1>
<p>Gets the blend factors and their corresponding blend positions from a <strong>LinearGradientBrush</strong> object.</p>
<pre><code>FUNCTION GetInterpolationColors (BYVAL presetColors AS ARGB PTR, _
   BYVAL blendPositions AS SINGLE PTR, BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>presetColors</em></td>
<td>Pointer to an array that receives the colors. A color of a given index in the presetColors array corresponds to the blend position of that same index in the <em>blendPositions</em> array.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array that receives the blend positions. Each number in the array indicates a percentage of the distance between the starting boundary and the ending boundary and is in the range from 0.0 through 1.0, where 0.0 indicates the starting boundary of the gradient and 1.0 indicates the ending boundary. A blend position between 0.0 and 1.0 indicates a line, parallel to the boundary lines, that is a certain fraction of the distance from the starting boundary to the ending boundary. For example, a blend position of 0.7 indicates the line that is 70 percent of the distance from the starting boundary to the ending boundary. The color is constant on lines that are parallel to the boundary lines.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Integer that specifies the number of elements in the presetColors array. This is the same as the number of elements in the blendPositions array. Before calling the <strong>GetInterpolationColors</strong> method of a <strong>LinearGradientBrush</strong> object, call the <strong>GetInterpolationColorCount</strong> method of that same <strong>LinearGradientBrush</strong> object to determine the current number of colors. The number of blend positions retrieved is the same as the number of colors retrieved.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-11">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-9">Example</h4>
<pre><code>' ========================================================================================
' The following example sets the colors that are interpolated for this linear gradient
' brush to red, blue, and green and sets the blend positions to 0, 0.3, and 1. The code
' calls the LinearGradientBrush::GetInterpolationColorCount method of a LinearGradientBrush
' object to obtain the number of colors currently set to be interpolated for the brush.
' Next, the code gets the colors and their positions. Then, the code fills a small
' rectangle with each color.
' ========================================================================================
SUB Example_GetInterpolationColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush, and set the colors to be interpolated.
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 0)}
   DIM positions(0 TO 2) AS SINGLE = {0.0, 0.3, 1.0}

   DIM pt1 AS GpPoint = GDIP_POINT(0, 0)
   DIM pt2 AS GpPoint = GDIP_POINT(100, 0)

   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 255, 255, 255))
   linGrBrush.SetInterpolationColors(@colors(0), @positions(0), 3)

   ' // Obtain information about the linear gradient brush.
   ' // How many colors have been specified to be interpolated for this brush?
   DIM colorCount AS LONG = linGrBrush.GetInterpolationColorCount

   ' // Allocate a buffer large enough to hold the set of colors.
   DIM rgcolors(0 TO colorCount - 1) AS ARGB

   ' // Allocate a buffer to hold the relative positions of the colors.
   DIM rgPositions(0 TO colorCount - 1) AS SINGLE

   ' // Get the colors and their relative positions.
   linGrBrush.GetInterpolationColors(@rgcolors(0), @rgPositions(0), colorCount)

   ' // Fill a small rectangle with each of the colors.
   DIM pSolidBrush AS CGpSolidBrush PTR
   FOR j AS LONG = 0 TO colorCount - 1
      pSolidBrush = NEW CGpSolidBrush(rgcolors(j))
      graphics.FillRectangle(pSolidBrush, 15 * j, 0, 10, 10)
      Delete pSolidBrush
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getlinearcolors-(cgplineargradientbrush)"><a name="GetLinearColors"></a>GetLinearColors (CGpLinearGradientBrush)</h1>
<p>Gets the starting color and ending color of this linear gradient brush.</p>
<pre><code>FUNCTION GetLinearColors (BYVAL colors AS ARGB PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colors</em></td>
<td>Pointer to an array that receives the starting color and the ending color. The first color in the colors array is the color at the starting boundary line of the gradient; the second color in the colors array is the color at the ending boundary line.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-12">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-10">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and gets the boundary colors. Next,
' the code uses each of the two colors to create a solid brush. Then, the code fills a
' rectangle with each solid brush.
' ========================================================================================
SUB Example_GetLinearColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush.
   DIM rc AS GpRect = GDIP_RECT(0, 0, 100, 50)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
      GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   ' // Obtain information about the linear gradient brush.
   DIM colors(0 TO 1) AS ARGB
   linGrBrush.GetLinearColors(@colors(0))

   ' // Fill a small rectangle with each of the two colors.
   DIM solidBrush0 AS CGpSolidBrush = colors(0)
   DIM solidBrush1 AS CGpSolidBrush = colors(1)
   graphics.FillRectangle(@solidBrush0, 0, 0, 20, 20)
   graphics.FillRectangle(@solidBrush1, 25, 0, 20, 20)

END SUB
' ========================================================================================
</code></pre>
<h1 id="getrectangle-(cgplineargradientbrush)"><a name="GetRectangleLGBrush"></a>GetRectangle (CGpLinearGradientBrush)</h1>
<p>Gets the rectangle that defines the boundaries of the gradient.</p>
<pre><code>FUNCTION GetRectangle (BYVAL rc AS GpRectF PTR) AS GpStatus
FUNCTION GetRectangle (BYVAL rc AS GpRect PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>rc</em></td>
<td>Pointer to a <strong>GpRectF</strong> or <strong>GpRect</strong> structure that receives the rectangle that defines the boundaries of the gradient. For example, if a linear gradient brush is constructed with a starting point at (20.2, 50.8) and an ending point at (60.5, 110.0), then the defining rectangle has its upper-left point at (20.2, 50.8), a width of 40.3, and a height of 59.2.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-13">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-2">Remarks</h4>
<p>The rectangle defines the boundaries of the gradient in the following ways: the right and left sides of the rectangle form the boundaries of a horizontal gradient; the top and bottom sides form the boundaries of a vertical gradient; two of the diagonally opposing corners lie on the boundaries of a diagonal gradient. In each of these cases, either side/corner may be on the starting boundary, depending on how the starting and ending points are passed to the constructor.</p>
<h4 id="example-11">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush. Then the code gets the brush's
' rectangle and draws it.
' ========================================================================================
SUB Example_GetRectangle (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush.
   DIM pt1 AS GpPoint = GDIP_POINT(20, 10)
   DIM pt2 AS GpPoint = GDIP_POINT(60, 110)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, _
      GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 0, 0, 255))

   ' // Obtain information about the linear gradient brush.
   DIM rc AS GpRect
   linGrBrush.GetRectangle(@rc)

   ' // Draw the retrieved rectangle.
   DIM pen AS CGpPen = GDIP_ARGB(255, 0, 0, 0)
   graphics.DrawRectangle(@pen, @rc)

END SUB
' ========================================================================================
</code></pre>
<h1 id="gettransform-(cgplineargradientbrush)"><a name="GetTransformLGBrush"></a>GetTransform (CGpLinearGradientBrush)</h1>
<p>Gets the transformation matrix of this linear gradient brush.</p>
<pre><code>FUNCTION GetTransform (BYVAL pMatrix AS CGpMatrix PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a <strong>Matrix</strong> object that receives the transformation matrix.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-14">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-3">Remarks</h4>
<p>A <strong>LinearGradientBrush</strong> object maintains a transformation matrix that can store any affine transformation. When you use a linear gradient brush to fill an area, GDI+ transforms the brush's boundary lines according to the brush's transformation matrix and then fills the area. The transformed boundaries exist only during rendering; the boundaries stored in the <strong>LinearGradientBrush</strong> object are not transformed</p>
<h4 id="example-12">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and sets its transformation matrix.
' Next, the code gets the brush's transformation matrix and proceeds to inspect or use the
' matrix elements.
' ========================================================================================
SUB Example_GetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush.
   DIM pt1 AS GpPoint = GDIP_POINT(0, 0)
   DIM pt2 AS GpPoint = GDIP_POINT(200, 0)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, _
      GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 0, 0, 255))

   DIM matrixSet AS CGpMatrix = CGpMatrix(0, 1, -1, 0, 0, 0)

   linGrBrush.SetTransform(@matrixSet)

   ' // Obtain information about the linear gradient brush.
   DIM matrixGet AS CGpMatrix
   DIM elements(0 TO 5) AS SINGLE

   linGrBrush.GetTransform(@matrixGet)
   matrixGet.GetElements(@elements(0))

   graphics.FillRectangle(@CGpSolidBrush(GDIP_ARGB(255, 0, 0, 0)), 0, 0, 20, 20)

   FOR j AS LONG = 0 TO 5
      ' // Inspect or use the value in elements[j].
      PRINT STR(elements(j))
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getwrapmode-(cgplineargradientbrush)"><a name="GetWrapModeLGBrush"></a>GetWrapMode (CGpLinearGradientBrush)</h1>
<p>Gets the wrap mode for this brush. The wrap mode determines how an area is tiled when it is painted with a brush.</p>
<pre><code>FUNCTION GetWrapMode () AS WrapMode
</code></pre>
<h4 id="return-value-15">Return value</h4>
<p>This method returns one of the following elements of the <strong>WrapMode</strong> enumeration:</p>
<ul>
<li>WrapModeTile</li>
<li>WrapModeTileFlipX</li>
<li>WrapModeTileFlipY</li>
<li>WrapModeTileFlipXY</li>
</ul>
<h4 id="example-13">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and sets its wrap mode. Next, the
' code gets the brush's wrap mode and performs tasks based on the brush's current wrap mode.
' ========================================================================================
SUB Example_GetWrapMode (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush.
   DIM rc AS GpRect = GDIP_RECT(0, 0, 100, 50)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
      GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   linGrBrush.SetWrapMode(WrapModeTileFlipX)

   ' // Obtain information about the linear gradient brush.
   DIM nWrapMode AS WrapMode
   nWrapMode = linGrBrush.GetWrapMode

   IF nWrapMode = WrapModeTileFlipX THEN
      ' // Do some task
   ELSEIF nWrapMode = WrapModeTileFlipY THEN
      ' // Do a different task
   END IF

END SUB
' ========================================================================================
</code></pre>
<h1 id="multiplytransform-(cgplineargradientbrush)"><a name="MultiplyTransformLGBrush"></a>MultiplyTransform (CGpLinearGradientBrush)</h1>
<p>Updates this brush's transformation matrix with the product of itself and another matrix.</p>
<pre><code>FUNCTION MultiplyTransform (BYVAL pMatrix AS CGpMatrix PTR, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a matrix to be multiplied by the brush's current transformation matrix.</td>
</tr>
<tr class="even">
<td><em>order</em></td>
<td>Optional. Element of the MatrixOrder enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-16">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-4">Remarks</h4>
<p>A single 3 ×3 matrix can store any sequence of affine transformations. If you have several 3 ×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3 ×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix R represents a rotation, and matrix T represents a translation. If matrix M is the product RT, then matrix M represents a composite transformation: first rotate, then translate.</p>
<p>The order of matrix multiplication is important. In general, the matrix product RT is not the same as the matrix product TR. In the example given in the previous paragraph, the composite transformation represented by RT (first rotate, then translate) is not the same as the composite transformation represented by TR (first translate, then rotate).</p>
<h4 id="example-14">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code sets the brush's transformation matrix, fills a rectangle with the
' transformed brush, modifies the brush's transformation matrix, and again fills a rectangle
' with the transformed brush.
' ========================================================================================
SUB Example_MultiplyTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM S AS CGpMatrix = CGpMatrix(2, 0, 0, 1, 0, 0)    ' // horizontal doubling
   DIM T AS CGpMatrix = CGpMatrix(1, 0, 0, 1, 50, 0)   '  // horizontal translation of 50 units

   DIM rc AS GpRect = GDIP_RECT(0, 0, 200, 100)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
       GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   ' // Fill a large area with the gradient brush (no transformation).
   graphics.FillRectangle(@linGrBrush, 0, 0, 800, 100)

   ' // Apply the scaling transformation.
   linGrBrush.SetTransform(@S)

   ' // Fill a large area with the scaled gradient brush.
   graphics.FillRectangle(@linGrBrush, 0, 150, 800, 100)

   ' // Form a composite transformation: first scale, then translate.
   linGrBrush.MultiplyTransform(@T, MatrixOrderAppend)

   ' // Fill a large area with the scaled and translated gradient brush.
   graphics.FillRectangle(@linGrBrush, 0, 300, 800, 100)

END SUB
' ========================================================================================
</code></pre>
<h1 id="resettransform-(cgplineargradientbrush)"><a name="ResetTransformLGBrush"></a>ResetTransform (CGpLinearGradientBrush)</h1>
<p>Resets the transformation matrix of this linear gradient brush to the identity matrix. This means that no transformation takes place.</p>
<pre><code>FUNCTION ResetTransform () AS GpStatus
</code></pre>
<h4 id="return-value-17">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-15">Example</h4>
<pre><code> ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code sets the brush's transformation matrix, fills a rectangle with the
' transformed brush, resets the brush's transformation matrix, and fills a rectangle with
' the untransformed brush.
' ========================================================================================
SUB Example_ResetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM S AS CGpMatrix = CGpMatrix(2, 0, 0, 1, 0, 0)    ' // horizontal doubling

   DIM rc AS GpRect = GDIP_RECT(0, 0, 200, 100)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
       GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   ' // Fill a large area with the gradient brush (no transformation).
   graphics.FillRectangle(@linGrBrush, 0, 0, 800, 100)

   ' // Apply the scaling transformation.
   linGrBrush.SetTransform(@S)

   ' // Fill a large area with the scaled gradient brush.
   graphics.FillRectangle(@linGrBrush, 0, 150, 800, 100)

   ' // Reset the transformation
   linGrBrush.ResetTransform

   ' // Fill a large area with the gradient brush (no transformation)
   graphics.FillRectangle(@linGrBrush, 0, 300, 800, 100)

END SUB
' ========================================================================================
</code></pre>
<h1 id="rotatetransform-(cgplineargradientbrush)"><a name="RotateTransformLGBrush"></a>RotateTransform (CGpLinearGradientBrush)</h1>
<p>Updates this brush's current transformation matrix with the product of itself and a rotation matrix.</p>
<pre><code>FUNCTION RotateTransform (BYVAL angle AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>angle</em></td>
<td>Single precision number that specifies the angle of rotation in degrees.</td>
</tr>
<tr class="even">
<td><em>order</em></td>
<td>Optional. Element of the MatrixOrder enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-18">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-5">Remarks</h4>
<p>A single 3 ×3 matrix can store any sequence of affine transformations. If you have several 3 ×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3 ×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix T represents a translation, and matrix R represents a rotation. If matrix M is the product TR, then matrix M represents a composite transformation: first translate, then rotate.</p>
<p>The order of matrix multiplication is important. In general, the matrix product RT is not the same as the matrix product TR. In the example given in the previous paragraph, the composite transformation represented by RT (first rotate, then translate) is not the same as the composite transformation represented by TR (first translate, then rotate).</p>
<h4 id="example-16">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code modifies the brush's transformation matrix, applying a composite transformation,
' and then fills a rectangle with the transformed brush.
' ========================================================================================
SUB Example_RotateTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM rc AS GpRect = GDIP_RECT(0, 0, 80, 40)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
       GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   ' // Fill a large area with the gradient brush (no transformation).
   graphics.FillRectangle(@linGrBrush, 0, 0, 800, 150)

   ' // Apply a composite transformation: first scale, then rotate.
   linGrBrush.ScaleTransform(2, 1)   '                 ' // horizontal doubling
   linGrBrush.RotateTransform(20, MatrixOrderAppend)   ' // 20-degree rotation

   ' // Fill a large area with the transformed linear gradient brush.
   graphics.FillRectangle(@linGrBrush, 0, 200, 800, 150)

END SUB
' ========================================================================================
</code></pre>
<h1 id="scaletransform-(cgplineargradientbrush)"><a name="ScaleTransformLGBrush"></a>ScaleTransform (CGpLinearGradientBrush)</h1>
<p>Updates this brush's current transformation matrix with the product of itself and a scaling matrix.</p>
<pre><code>FUNCTION ScaleTransform (BYVAL sx AS SINGLE, BYVAL sy AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>sx</em></td>
<td>Single precision number that specifies the amount to scale in the x direction.</td>
</tr>
<tr class="even">
<td><em>sy</em></td>
<td>Single precision number that specifies the amount to scale in the y direction.</td>
</tr>
<tr class="odd">
<td><em>order</em></td>
<td>Optional. Element of the <strong>MatrixOrder</strong> enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-19">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-6">Remarks</h4>
<p>A single 3 ×3 matrix can store any sequence of affine transformations. If you have several 3 ×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3 ×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix T represents a translation, and matrix S represents a scaling. If matrix M is the product TS, then matrix M represents a composite transformation: first translate, then scale.</p>
<p>The order of matrix multiplication is important. In general, the matrix product RT is not the same as the matrix product TR. In the example given in the previous paragraph, the composite transformation represented by RT (first rotate, then translate) is not the same as the composite transformation represented by TR (first translate, then rotate).</p>
<h4 id="example-17">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code modifies the brush's transformation matrix, applying a composite transformation,
' and then fills a rectangle with the transformed brush.
' ========================================================================================
SUB Example_ScaleTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM rc AS GpRect = GDIP_RECT(0, 0, 80, 40)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
       GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   ' // Fill a large area with the gradient brush (no transformation).
   graphics.FillRectangle(@linGrBrush, 0, 0, 800, 150)

   ' // Apply a composite transformation: first translate, then scale.
   linGrBrush.RotateTransform(60, 0)   ' // horizontal translation
   linGrBrush.ScaleTransform(2, 1)     ' // horizontal doubling

   ' // Fill a large area with the transformed linear gradient brush.
   graphics.FillRectangle(@linGrBrush, 0, 200, 800, 150)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setblend-(cgplineargradientbrush)"><a name="SetBlendLGBrush"></a>SetBlend (CGpLinearGradientBrush)</h1>
<p>Sets the blend factors and the blend positions of this linear gradient brush to create a custom blend.</p>
<pre><code>FUNCTION SetBlend (BYVAL blendFactors AS SINGLE PTR, BYVAL blendPositions AS SINGLE PTR, _
   BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>blendFactors</em></td>
<td>Pointer to an array of single precision numbers that specify blend factors. Each number in the array specifies a percentage of the ending color and should be in the range from 0.0 through 1.0.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array of single precision numbers that specify blend positions. Each number in the array indicates a percentage of the distance between the starting boundary and the ending boundary and is in the range from 0.0 through 1.0, where 0.0 indicates the starting boundary of the gradient and 1.0 indicates the ending boundary. There must be at least two positions specified: the first position, which is always 0.0f, and the last position, which is always 1.0f. Otherwise, the behavior is undefined. A blend position between 0.0 and 1.0 indicates a line, parallel to the boundary lines, that is a certain fraction of the distance from the starting boundary to the ending boundary. For example, a blend position of 0.7 indicates the line that is 70 percent of the distance from the starting boundary to the ending boundary. The color is constant on lines that are parallel to the boundary lines.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Optional. Integer that specifies the number of elements in the blendFactors array. This is the same as the number of elements in the <em>blendPositions</em> array. The blend factor at a given array index corresponds to the blend position at that same array index.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-20">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-7">Remarks</h4>
<p>A <strong>LinearGradientBrush</strong> object has two boundaries. When you fill an area with a linear gradient brush, the color changes gradually as you move from the starting boundary to the ending boundary. By default, the color is linearly related to the distance, but you can customize the relationship between color and distance by calling the <strong>SetBlend</strong> method.</p>
<h4 id="example-18">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush, sets a custom blend, and uses the
' brush to fill a rectangle.
' ========================================================================================
SUB Example_SetBlend (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM factors(0 TO 3) AS SINGLE = {0.0, 0.4, 0.6, 1.0}
   DIM positions(0 TO 3) AS SINGLE = {0.0, 0.2, 0.8, 1.0}
   DIM rcf AS GpRectF = GDIP_RECTF(0, 0, 100, 50)

   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rcf, GDIP_ARGB(255, 255, 0, 0), _
       GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   linGrBrush.SetBlend(@factors(0), @positions(0), 4)
   graphics.FillRectangle(@linGrBrush, @rcf)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setblendbellshape-(cgplineargradientbrush)"><a name="SetBlendBellShapeLGBrush"></a>SetBlendBellShape (CGpLinearGradientBrush)</h1>
<p>Sets the blend shape of this path gradient brush.</p>
<pre><code>FUNCTION SetBlendBellShape (BYVAL focus AS SINGLE, BYVAL scale AS SINGLE = 1.0) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>focus</em></td>
<td>Single precision number that specifies where the center color will be at its highest intensity. This number must be in the range 0 through 1.</td>
</tr>
<tr class="even">
<td><em>scale</em></td>
<td>Single precision number that specifies the maximum intensity of center color that gets blended with the boundary color. This number must be in the range 0 through 1. The default value is 1.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-21">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-8">Remarks</h4>
<p>By default, the color changes gradually from the starting color (color at the starting boundary of the linear gradient brush) to the ending color (color at the ending boundary of the linear gradient brush) as you move from the starting boundary to the ending boundary. You can customize the positioning and blending of the starting and ending colors by using the SetBlendBellShape method.</p>
<p>The <strong>SetBlendBellShape</strong> method customizes the blend so that it follows a bell-shaped curve with the extremes of the bell's base at the gradient's boundaries. The starting color, which, in a default blend, is at the starting boundary of a linear gradient brush, appears at the starting and ending boundaries of the linear gradient brush when a bell-shaped blend is applied. The position of the ending color, which, in a default blend, is at the ending boundary, is somewhere between the boundaries and is determined by the value of the focus. In other words, the focus specifies the position of the peak of the bell. For example, a focus value of 0.7 places the peak at 70 percent of the distance between the starting and ending boundaries. The ending color appears at this peak.</p>
<p>The ending color in a bell-shaped blend is a percentage of the gamut between the gradient's default-blend starting color and default-blend ending color. For example, suppose a linear gradient brush is constructed with red as the starting color and blue as the ending color. If <strong>SetBlendBellShape</strong> is called with a scale value of 0.8, the ending color in the bell shaped blend is a hue that is 80 percent between red and blue (20 percent red, 80 percent blue). A scale value of 1.0 produces an ending color that is 100 percent blue.</p>
<h4 id="example-19">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush, sets a bell-shaped blend, and uses
' the brush to fill a rectangle. Twice more, the code sets a bell-shaped blend with different
' values and, each time, uses the brush to fill a rectangle.
' ========================================================================================
SUB Example_SetBlendBellShape (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM pt1 AS GpPoint = GDIP_POINT(0, 0)
   DIM pt2 AS GpPoint = GDIP_POINT(500, 0)

   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, _
      GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255))

   linGrBrush.SetBlendBellShape(0.5, 0.6)
   graphics.FillRectangle(@linGrBrush, 0, 0, 500, 50)

   linGrBrush.SetBlendBellShape(0.5, 0.8)
   graphics.FillRectangle(@linGrBrush, 0, 75, 500, 50)

   linGrBrush.SetBlendBellShape(0.5, 1.0)
   graphics.FillRectangle(@linGrBrush, 0, 150, 500, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setblendtriangularshape-(cgplineargradientbrush)"><a name="SetBlendTriangularShapeLGBrush"></a>SetBlendTriangularShape (CGpLinearGradientBrush)</h1>
<p>Sets the blend shape of this path gradient brush.</p>
<pre><code>FUNCTION SetBlendTriangularShape (BYVAL focus AS SINGLE, BYVAL scale AS SINGLE = 1.0) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>focus</em></td>
<td>Single precision number that specifies where the center color will be at its highest intensity. This number must be in the range 0 through 1.</td>
</tr>
<tr class="even">
<td><em>scale</em></td>
<td>Single precision number that specifies the maximum intensity of center color that gets blended with the boundary color. This number must be in the range 0 through 1. The default value is 1.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-22">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-9">Remarks</h4>
<p>By default, the color changes gradually from the starting color (color at the starting boundary of the linear gradient brush) to the ending color (color at the ending boundary of the linear gradient brush) as you move from the starting boundary to the ending boundary. You can customize the positioning and blending of the starting and ending colors by using the <strong>SetBlendTriangularShape</strong> method.</p>
<p>The <strong>SetBlendTriangularShape</strong> method customizes the blend so that it follows a triangular shape with the extremes of the triangle's base at the gradient's boundaries. The starting color, which, in a default blend, is at the starting boundary of a linear gradient brush, appears at the starting and ending boundaries of the linear gradient brush when a triangular-shaped blend is applied. The position of the ending color, which, in a default blend, is at the ending boundary, is somewhere between the boundaries and is determined by the value of the focus. In other words, the focus specifies the position of the peak of the triangle. For example, a focus value of 0.5 places the peak half way between the starting and ending boundaries. The ending color appears at this peak.</p>
<p>The ending color in a triangular-shaped blend is a percentage of the gamut between the gradient's default-blend starting color and default-blend ending color. For example, suppose a linear gradient brush is constructed with red as the starting color and blue as the ending color. If <strong>SetBlendTriangularShape</strong> is called with a scale value of 0.3, the ending color in the triangular-shaped blend is a hue that is 30 percent between red and blue (70 percent red, 30 percent blue). A scale value of 1.0 produces an ending color that is 100 percent blue.</p>
<h4 id="example-20">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush, sets a triangular-shaped blend,
' and uses the brush to fill a rectangle. Twice more, the code sets a triangular-shaped
' blend with different values and, each time, uses the brush to fill a rectangle.
' ========================================================================================
SUB Example_SetBlendTriangularShape (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM pt1 AS GpPoint = GDIP_POINT(0, 0)
   DIM pt2 AS GpPoint = GDIP_POINT(500, 0)

   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, _
      GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255))

   linGrBrush.SetBlendTriangularShape(0.5, 0.6)
   graphics.FillRectangle(@linGrBrush, 0, 0, 500, 50)

   linGrBrush.SetBlendTriangularShape(0.5, 0.8)
   graphics.FillRectangle(@linGrBrush, 0, 75, 500, 50)

   linGrBrush.SetBlendTriangularShape(0.5, 1.0)
   graphics.FillRectangle(@linGrBrush, 0, 150, 500, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setgammacorrection-(cgplineargradientbrush)"><a name="SetGammaCorrectionLGBrush"></a>SetGammaCorrection (CGpLinearGradientBrush)</h1>
<p>Specifies whether gamma correction is enabled for this linear gradient brush.</p>
<pre><code>FUNCTION SetGammaCorrection (BYVAL useGammaCorrection AS BOOL) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>useGammaCorrection</em></td>
<td>Boolean value that specifies whether gamma correction occurs during rendering. TRUE specifies that gamma correction is enabled, and FALSE specifies that gamma correction is not enabled. By default, gamma correction is disabled during construction of a <strong>LinearGradientBrush</strong> object.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-23">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-10">Remarks</h4>
<p>Gamma correction is often done to match the intensity contrast of the gradient to the ability of the human eye to perceive intensity changes.</p>
<h1 id="setgammacorrection-(cgppathgradientbrush)"><a name="SetGammaCorrectionPGBrush"></a>SetGammaCorrection (CGpPathGradientBrush)</h1>
<p>Specifies specifies whether gamma correction is enabled for this path gradient brush.</p>
<pre><code>FUNCTION SetGammaCorrection (BYVAL useGammaCorrection AS BOOL) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>useGammaCorrection</em></td>
<td>Boolean value that specifies whether gamma correction is enabled. TRUE specifies that gamma correction is enabled, and FALSE specifies that gamma correction is not enabled.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-24">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-11">Remarks</h4>
<p>Gamma correction is often done to match the intensity contrast of the gradient to the ability of the human eye to perceive intensity changes.</p>
<h1 id="setinterpolationcolors-(cgplineargradientbrush)"><a name="SetInterpolationColorsLGBrush"></a>SetInterpolationColors (CGpLinearGradientBrush)</h1>
<p>Specifies whether gamma correction is enabled for this linear gradient brush.</p>
<pre><code>FUNCTION SetInterpolationColors (BYVAL presetColors AS ARGB PTR, _
   BYVAL blendPositions AS SINGLE PTR, BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>presetColors</em></td>
<td>Pointer to an array of ARGB colors that specify the colors to be interpolated for this linear gradient brush. A color of a given index in the <em>presetColors</em> array corresponds to the blend position of that same index in the <em>blendPositions</em> array.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array of single precision numbers that specify the blend positions. Each number in the array specifies a percentage of the distance between the starting boundary and the ending boundary and is in the range from 0.0 through 1.0, where 0.0 indicates the starting boundary of the gradient and 1.0 indicates the ending boundary. There must be at least two positions specified: the first position, which is always 0.0f, and the last position, which is always 1.0f. Otherwise, the behavior is undefined. A blend position between 0.0 and 1.0 indicates the line, parallel to the boundary lines, that is a certain fraction of the distance from the starting boundary to the ending boundary. For example, a blend position of 0.7 indicates the line that is 70 percent of the distance from the starting boundary to the ending boundary. The color is constant on lines that are parallel to the boundary lines.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Integer that specifies the number of elements in the <em>presetColors</em> array. This is the same as the number of elements in the <em>blendPositions</em> array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-25">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-21">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush, sets the colors to be interpolated
' for the linear gradient brush, and fills a rectangle.
' ========================================================================================
SUB Example_SetInterpolationColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush, and set the colors to be interpolated.
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 0)}
   DIM positions(0 TO 2) AS SINGLE = {0.0, 0.3, 1.0}

   DIM pt1 AS GpPoint = GDIP_POINT(0, 0)
   DIM pt2 AS GpPoint = GDIP_POINT(100, 0)

   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@pt1, @pt2, GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 255, 255, 255))
   linGrBrush.SetInterpolationColors(@colors(0), @positions(0), 3)

   graphics.FillRectangle(@linGrBrush, 0, 0, 100, 50)
   
END SUB
' ========================================================================================
</code></pre>
<h1 id="setlinearcolors-(cgplineargradientbrush)"><a name="SetLinearColors"></a>SetLinearColors (CGpLinearGradientBrush)</h1>
<p>Sets the starting color and ending color of this linear gradient brush.</p>
<pre><code>FUNCTION SetLinearColors (BYVAL color1 AS ARGB, BYVAL color2 AS ARGB) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>color1</em></td>
<td>The color at the starting boundary line of this linear gradient brush.</td>
</tr>
<tr class="even">
<td><em>color2</em></td>
<td>The color that specifies the color at the ending boundary line of this linear gradient brush.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-26">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-22">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code changes the linear colors and uses the modified brush to fill another rectangle.
' ========================================================================================
SUB Example_SetLinearColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush.
   DIM rc AS GpRect = GDIP_RECT(0, 0, 100, 50)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
      GDIP_ARGB(255, 0, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   linGrBrush.SetLinearColors(GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 0))
   graphics.FillRectangle(@linGrBrush, 0, 75, 100, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="settransform-(cgplineargradientbrush)"><a name="SetTransformLGBrush"></a>SetTransform (CGpLinearGradientBrush)</h1>
<p>Sets the transformation matrix of this linear gradient brush.</p>
<pre><code>FUNCTION SetTransform (BYVAL pMatrix AS CGpMatrix PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a <strong>Matrix</strong> object that specifies the transformation matrix to use.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-27">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-12">Remarks</h4>
<p>A <strong>LinearGradientBrush</strong> object has a rectangle that specifies the starting and ending boundaries of the gradient and a mode or angle that affects the direction. If the brush's transformation matrix is set to represent any transformation other than the identity, then the boundaries and direction are transformed according to that matrix during rendering.</p>
<p>The transformation applies only during rendering. The boundaries stored by the <strong>LinearGradientBrush</strong> object are not altered by the <strong>SetTransform</strong> method.</p>
<h4 id="example-23">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code modifies the brush's transformation matrix and fills a rectangle with the
' transformed brush.
' ========================================================================================
SUB Example_SetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM rc AS GpRect = GDIP_RECT(0, 0, 80, 40)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
       GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   DIM matrix AS CGpMatrix = CGpMatrix(2.0, 0, 0, 1, 0, 0)   ' // horizontal doubling

   ' // Fill a large area with the gradient brush (no transformation).
   graphics.FillRectangle(@linGrBrush, 0, 0, 800, 50)

   linGrBrush.SetTransform(@matrix)

   ' // Fill a large area with the transformed linear gradient brush.
   graphics.FillRectangle(@linGrBrush, 0, 75, 800, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setwrapmode-(cgplineargradientbrush)"><a name="SetWrapModeLGBrush"></a>SetWrapMode (CGpLinearGradientBrush)</h1>
<p>Sets the wrap mode of this linear gradient brush.</p>
<pre><code>FUNCTION SetWrapMode (BYVAL wrapMode AS WrapMode) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>wrapMode</em></td>
<td>Element of the <strong>WrapMode</strong> enumeration that specifies how areas painted with this linear gradient brush will be tiled. The value of this parameter must be one of the following elements: <strong>WrapModeTile</strong>, <strong>WrapModeTileFlipX</strong>, <strong>WrapModeTileFlipY</strong>, <strong>WrapModeTileFlipXY</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-28">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-13">Remarks</h4>
<p>The boundary lines of a linear gradient brush form a tile. When you paint an area with a linear gradient brush, the tile repeats. A linear gradient brush may have alternate tiles flipped in a certain direction, as specified by the wrap mode. Flipping has the effect of reversing the order of the colors.</p>
<p>The wrap mode defaults to <strong>WrapModeTile</strong> when a <strong>LinearGradientBrush</strong> object is constructed.</p>
<h4 id="example-24">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code modifies the brush's wrap mode and uses the modified brush to fill another
' rectangle.
' ========================================================================================
SUB Example_SetWrapMode (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a linear gradient brush.
   DIM rc AS GpRect = GDIP_RECT(0, 0, 100, 50)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
      GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   ' // Fill a large area using the gradient brush with the default wrap mode.
   graphics.FillRectangle(@linGrBrush, 0, 0, 800, 50)

   linGrBrush.SetWrapMode(WrapModeTileFlipX)

   ' // Fill a large area using the gradient brush with the new wrap mode.
   graphics.FillRectangle(@linGrBrush, 0, 75, 800, 50)

END SUB
' ========================================================================================
</code></pre>
<h1 id="translatetransform-(cgplineargradientbrush)"><a name="TranslateTransformLGBrush"></a>TranslateTransform (CGpLinearGradientBrush)</h1>
<p>Updates this brush's current transformation matrix with the product of itself and a translation matrix.</p>
<pre><code>FUNCTION TranslateTransform (BYVAL dx AS SINGLE, BYVAL dy AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>dx</em></td>
<td>Single precision number that specifies the horizontal component of the translation.</td>
</tr>
<tr class="even">
<td><em>dy</em></td>
<td>Single precision number that specifies the vertical component of the translation.</td>
</tr>
<tr class="odd">
<td><em>order</em></td>
<td>Optional. Element of the <strong>MatrixOrder</strong> enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-29">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-14">Remarks</h4>
<p>A single 3×3 matrix can store any sequence of affine transformations. If you have several 3×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix <em>S</em> represents a scaling, and matrix <em>T</em> represents a translation. If matrix M is the product <em>ST</em>, then matrix <em>M</em> represents a composite transformation: first scale, then translate.</p>
<p>The order of matrix multiplication is important. In general, the matrix product <em>RT</em> is not the same as the matrix product <em>TR</em>. In the example given in the previous paragraph, the composite transformation represented by <em>RT</em> (first rotate, then translate) is not the same as the composite transformation represented by <em>TR</em> (first translate, then rotate).</p>
<h4 id="example-25">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a linear gradient brush and uses it to fill a rectangle.
' Next, the code modifies the brush's transformation matrix, applying a composite transformation,
' and then fills a rectangle with the transformed brush.
' ========================================================================================
SUB Example_TranslateTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM rc AS GpRect = GDIP_RECT(0, 0, 80, 40)
   DIM linGrBrush AS CGpLinearGradientBrush = CGpLinearGradientBrush(@rc, _
       GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), LinearGradientModeHorizontal)

   ' // Fill a large area with the gradient brush (no transformation).
   graphics.FillRectangle(@linGrBrush, 0, 0, 800, 150)

   ' // Apply a composite transformation: first scale, then translate.
   linGrBrush.ScaleTransform(2, 1)                           ' // horizontal doubling
   linGrBrush.TranslateTransform(30, 0, MatrixOrderAppend)   ' // translation

   ' // Fill a large area with the transformed linear gradient brush.
   graphics.FillRectangle(@linGrBrush, 0, 200, 800, 150)

END SUB
' ========================================================================================
</code></pre>
<h1 id="constructors-(cgppathgradientbrush)"><a name="ConstructorsPGBrush"></a>Constructors (CGpPathGradientBrush)</h1>
<p>Creates a <strong>PathGradientBrush</strong> object from another <strong>PathGradientBrush</strong> object.</p>
<pre><code>CONSTRUCTOR CGpPathGradientBrush (BYVAL pPathGradientBrush AS CGpPathGradientBrush PTR)
</code></pre>
<p>Creates a <strong>PathGradientBrush</strong> object based on an array of points. Initializes the wrap mode of the path gradient brush</p>
<pre><code>CONSTRUCTOR CGpPathGradientBrush (BYVAL pts AS GpPointF PTR, BYVAL nCount AS LONG, _
   BYVAL nWrapMode AS WrapMode = WrapModeClamp)
</code></pre>
<p>Creates a <strong>PathGradientBrush</strong> object based on an array of points. Initializes the wrap mode of the path gradient brush.</p>
<pre><code>CONSTRUCTOR CGpPathGradientBrush (BYVAL pts AS GpPoint PTR, BYVAL nCount AS LONG, _
   BYVAL nWrapMode AS WrapMode = WrapModeClamp)
</code></pre>
<p>Creates a <strong>PathGradientBrush</strong> object based on a GraphicsPath object.</p>
<pre><code>CONSTRUCTOR CGpPathGradientBrush (BYVAL pGraphPath AS CGpGraphicsPath PTR)
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pts</em></td>
<td>Pointer to an array of points that specifies the boundary path of the path gradient brush.</td>
</tr>
<tr class="even">
<td><em>nCount</em></td>
<td>Integer that specifies the number of elements in the <em>pts</em> array.</td>
</tr>
<tr class="odd">
<td><em>nWrapMode</em></td>
<td>Optional. Element of the <strong>WrapMode</strong> enumeration that specifies how areas painted with the path gradient brush will be tiled. The default value is <strong>WrapModeClamp</strong>.</td>
</tr>
<tr class="even">
<td><em>pGraphPath</em></td>
<td>Pointer to a <strong>GraphicsPath</strong> object that specifies the boundary path of the path gradient brush.</td>
</tr>
</tbody>
</table>
<h1 id="getblend-(cgppathgradientbrush)"><a name="GetBlendPGBrush"></a>GetBlend (CGpPathGradientBrush)</h1>
<p>Gets the blend factors and the corresponding blend positions currently set for this path gradient brush.</p>
<pre><code>FUNCTION GetBlend (BYVAL blendFactors AS SINGLE PTR, BYVAL blendPositions AS SINGLE PTR, _
   BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>blendFactors</em></td>
<td>Pointer to an array that receives the blend factors.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array that receives the blend positions.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Integer that specifies the number of blend factors to retrieve. Before calling the <strong>GetBlend</strong> method of a <strong>PathGradientBrush</strong> object, call the <strong>GetBlendCount</strong> method of that same <strong>PathGradientBrush</strong> object to determine the current number of blend factors. The number of blend positions retrieved is the same as the number of blend factors retrieved.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-30">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-15">Remarks</h4>
<p>A <strong>PathGradientBrush</strong> object has a boundary path and a center point. When you fill an area with a path gradient brush, the color changes gradually as you move from the boundary path to the center point. By default, the color is linearly related to the distance, but you can customize the relationship between color and distance by calling the SetBlend method.</p>
<h4 id="example-26">Example</h4>
<pre><code>' ========================================================================================
' The following example demonstrates several methods of the PathGradientBrush class including
' PathGradientBrush.SetBlend, PathGradientBrush.GetBlendCount, and PathGradientBrush.GetBlend.
' The code creates a PathGradientBrush object and calls the PathGradientBrush.SetBlend method
' to establish a set of blend factors and blend positions for the brush. Then the code calls
' the PathGradientBrush.GetBlendCount method to retrieve the number of blend factors. After
' the number of blend factors is retrieved, the code allocates two buffers: one to receive
' the array of blend factors and one to receive the array of blend positions. Then the code
' calls the PathGradientBrush.GetBlend method to retrieve the blend factors and the blend
' positions.
' ========================================================================================
SUB Example_GetBlend (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   ' // Set blend factors and positions for the path gradient brush.
   DIM factors(0 TO 3) AS SINGLE = {0.0, 0.4, 0.8, 1.0}
   DIM positions(0 TO 3) AS SINGLE = {0.0, 0.3, 0.7, 1.0}

   pthGrBrush.SetBlend(@factors(0), @positions(0), 4)

   ' // Fill the ellipse with the path gradient brush.
   graphics.FillEllipse(@pthGrBrush, 0, 0, 200, 100)

   ' // Obtain information about the path gradient brush.
   DIM blendCount AS LONG = pthGrBrush.GetBlendCount
   DIM rgFactors(blendCount - 1) AS SINGLE
   DIM rgPositions(blendCount - 1) AS SINGLE

   pthGrBrush.GetBlend(@rgFactors(0), @rgPositions(0), blendCount)

   FOR j AS LONG = 0 TO blendCount - 1
'      // Inspect or use the value in rgFactors(j)
'      // Inspect or use the value in rgPositions(j)
      OutputDebugString STR(rgFactors(j)) &amp; STR(rgPositions(j))
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getblendcount-(cgppathgradientbrush)"><a name="GetBlendCountPGBrush"></a>GetBlendCount (CGpPathGradientBrush)</h1>
<p>Gets the number of blend factors currently set for this path gradient brush.</p>
<pre><code>FUNCTION GetBlendCount () AS INT_
</code></pre>
<h4 id="return-value-31">Return value</h4>
<p>Before you call the <strong>GetBlend</strong> method of a <strong>PathGradientBrush</strong> object, you must allocate two buffers: one to receive an array of blend factors and one to receive an array of blend positions. To determine the size of the required buffers, call the <strong>GetBlendCount</strong> method of the <strong>PathGradientBrush</strong> object. The size (in bytes) of each buffer should be the return value of <strong>GetBlendCount</strong> multiplied by 4 (the size of a single precision number).</p>
<h4 id="example-27">Example</h4>
<pre><code>' ========================================================================================
' The following example demonstrates several methods of the PathGradientBrush class including
' PathGradientBrush.SetBlend, PathGradientBrush.GetBlendCount, and PathGradientBrush.GetBlend.
' The code creates a PathGradientBrush object and calls the PathGradientBrush.SetBlend method
' to establish a set of blend factors and blend positions for the brush. Then the code calls
' the PathGradientBrush.GetBlendCount method to retrieve the number of blend factors. After
' the number of blend factors is retrieved, the code allocates two buffers: one to receive
' the array of blend factors and one to receive the array of blend positions. Then the code
' calls the PathGradientBrush.GetBlend method to retrieve the blend factors and the blend
' positions.
' ========================================================================================
SUB Example_GetBlend (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   ' // Set blend factors and positions for the path gradient brush.
   DIM factors(0 TO 3) AS SINGLE = {0.0, 0.4, 0.8, 1.0}
   DIM positions(0 TO 3) AS SINGLE = {0.0, 0.3, 0.7, 1.0}

   pthGrBrush.SetBlend(@factors(0), @positions(0), 4)

   ' // Fill the ellipse with the path gradient brush.
   graphics.FillEllipse(@pthGrBrush, 0, 0, 200, 100)

   ' // Obtain information about the path gradient brush.
   DIM blendCount AS LONG = pthGrBrush.GetBlendCount
   DIM rgFactors(blendCount - 1) AS SINGLE
   DIM rgPositions(blendCount - 1) AS SINGLE

   pthGrBrush.GetBlend(@rgFactors(0), @rgPositions(0), blendCount)

   FOR j AS LONG = 0 TO blendCount - 1
'      // Inspect or use the value in rgFactors(j)
'      // Inspect or use the value in rgPositions(j)
      OutputDebugString STR(rgFactors(j)) &amp; STR(rgPositions(j))
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getcentercolor-(cgppathgradientbrush)"><a name="GetCenterColor"></a>GetCenterColor (CGpPathGradientBrush)</h1>
<p>Gets the center color of this path gradient brush.</p>
<pre><code>FUNCTION GetCenterColor (BYVAL colour AS ARGB PTR) AS GpStatus
FUNCTION GetCenterColor () AS ARGB
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colour</em></td>
<td>Pointer to a variable that receives the color of the center point.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-32">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<p>The second overloaded function returns the ARGB color as the result of the function.</p>
<h4 id="remarks-16">Remarks</h4>
<p>By default, the center point of a <strong>PathGradientBrush</strong> object is the centroid of the brush's boundary path, but you can set the center point to any location, inside or outside the path, by calling the <strong>SetCenterPoint</strong> method of the <strong>PathGradientBrush</strong> object.</p>
<h4 id="example-28">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object and uses it to fill an ellipse.
' Then the code calls the PathGradientBrush.GetCenterColor method of the PathGradientBrush
' object to obtain the center color.
' ========================================================================================
SUB Example_GetCenterColor (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   ' // Fill the ellipse with the path gradient brush.
   graphics.FillEllipse(@pthGrBrush, 0, 0, 200, 100)

   ' // Obtain information about the path gradient brush.
   DIM colour AS ARGB
   pthGrBrush.GetCenterColor(@colour)

   ' // Fill a rectangle with the retrieved color.
   DIM solidBrush AS CGpSolidBrush = colour
   graphics.FillRectangle(@solidBrush, 0, 120, 200, 30)

END SUB
' ========================================================================================
</code></pre>
<h1 id="getcenterpoint-(cgppathgradientbrush)"><a name="GetCenterPoint"></a>GetCenterPoint (CGpPathGradientBrush)</h1>
<p>Gets the center point of this path gradient brush.</p>
<pre><code>FUNCTION GetCenterPoint (BYVAL pt AS PointF PTR) AS GpStatus
FUNCTION GetCenterPoint (BYVAL pt AS Point PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pt</em></td>
<td>Pointer to a <strong>PointF</strong> or <strong>Point</strong> structure that receives the center point.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-33">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-17">Remarks</h4>
<p>By default, the center point of a <strong>PathGradientBrush</strong> object is at the centroid of the brush's boundary path, but you can set the center point to any location, inside or outside the path, by calling the <strong>SetCenterPoint</strong> method of the <strong>PathGradientBrush</strong> object.</p>
<h4 id="example-29">Example</h4>
<pre><code>' ========================================================================================
' The following example demonstrates several methods of the PathGradientBrush class including
' PathGradientBrush.GetCenterPoint and PathGradientBrush.SetCenterColor. The code creates
' a PathGradientBrush object and then sets the brush's center color and boundary color.
' The code calls the PathGradientBrush.GetCenterPoint method to determine the center point
' of the path gradient and then draws a line from the origin to that center point.
' ========================================================================================
SUB Example_GetCenterPoint (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   ' // Fill the ellipse with the path gradient brush.
   graphics.FillEllipse(@pthGrBrush, 0, 0, 200, 100)

   ' // Obtain information about the path gradient brush.
   DIM centerPoint AS GpPointF
   pthGrBrush.GetCenterPoint(@centerPoint)

   ' // Draw a line from the origin to the center of the ellipse.
   DIM pen AS CGpPen = GDIP_ARGB(255, 0, 255, 0)
   DIM pt AS GpPointF = GDIP_POINTF(0, 0)
   graphics.DrawLine(@pen, @pt, @centerPoint)
   
END SUB
' ========================================================================================
</code></pre>
<h1 id="getfocusscales-(cgppathgradientbrush)"><a name="GetFocusScales"></a>GetFocusScales (CGpPathGradientBrush)</h1>
<p>Gets the focus scales of this path gradient brush.</p>
<pre><code>FUNCTION GetFocusScales (BYVAL xScale AS SINGLE PTR, BYVAL yScale AS SINGLE PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>xScale</em></td>
<td>Pointer to a single precision that receives the x focus scale value.</td>
</tr>
<tr class="even">
<td><em>yScale</em></td>
<td>Pointer to a single precision that receives the y focus scale value.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-34">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-18">Remarks</h4>
<p>By default, the center color of a path gradient is at the center point. By calling <strong>SetFocusScales</strong>, you can specify that the center color should appear along a path that surrounds the center point. For example, suppose the boundary path is a triangle and the center point is at the centroid of that triangle. Also assume that the boundary color is red and the center color is blue. If you set the focus scales to (0.2, 0.2), the color is blue along the boundary of a small triangle that surrounds the center point. That small triangle is the main boundary path scaled by a factor of 0.2 in the x direction and 0.2 in the y direction. When you paint with the path gradient brush, the color will change gradually from red to blue as you move from the boundary of the large triangle to the boundary of the small triangle. The area inside the small triangle will be filled with blue.</p>
<h4 id="example-30">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path.
' The code sets the focus scales of the path gradient brush to (0.2, 0.2) and then uses
' the path gradient brush to fill an area that contains the triangular path. Finally, the
' code calls the PathGradientBrush.GetFocusScales method of the PathGradientBrush object
' to obtain the values of the x focus scale and the y focus scale.
' ========================================================================================
SUB Example_GetFocusScales (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(100, 0), GDIP_POINT(200, 200), GDIP_POINT(0, 200)}

   ' // No GraphicsPath object is created. The PathGradientBrush
   ' // object is constructed directly from the array of points.
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM colors(0 TO 1) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255)}

   ' // red at the boundary of the outer triangle
   ' // blue at the boundary of the inner triangle
   DIM relativePositions(0 TO 1) AS SINGLE = {0.0, 1.0}
   pthGrBrush.SetInterpolationColors(@colors(0), @relativePositions(0), 2)

   ' // The inner triangle is formed by scaling the outer triangle
   ' // about its centroid. The scaling factor is 0.2 in both the x and y directions.
   pthGrBrush.SetFocusScales(0.2, 0.2)

   ' // Fill a rectangle that is larger than the triangle
   ' // specified in the Point array. The portion of the
   ' // rectangle outside the triangle will not be painted.
   graphics.FillRectangle(@pthGrBrush, 0, 0, 200, 200)

   ' // Obtain information about the path gradient brush.
   DIM xScale AS SINGLE = 0.0
   DIM yScale AS SINGLE = 0.0
   pthGrBrush.GetFocusScales(@xScale, @yScale)

   ' // The value of xScale is now 0.2.
   ' // The value of yScale is now 0.2. 

END SUB
' ========================================================================================
</code></pre>
<h1 id="getgammacorrection-(cgppathgradientbrush)"><a name="GetGammaCorrectionPGBrush"></a>GetGammaCorrection (CGpPathGradientBrush)</h1>
<p>Determines whether gamma correction is enabled for this path gradient brush.</p>
<pre><code>FUNCTION GetGammaCorrection () AS BOOL
</code></pre>
<h4 id="return-value-35">Return value</h4>
<p>If gamma correction is enabled, this method returns TRUE; otherwise, it returns FALSE.</p>
<h1 id="getinterpolationcolorcount-(cgppathgradientbrush)"><a name="GetInterpolationColorCountPGBrush"></a>GetInterpolationColorCount (CGpPathGradientBrush)</h1>
<p>Gets the number of preset colors currently specified for this path gradient brush.</p>
<pre><code>FUNCTION GetInterpolationColorCount () AS INT_
</code></pre>
<h4 id="return-value-36">Return value</h4>
<p>This method returns the number of preset colors currently specified for this path gradient brush.</p>
<h4 id="remarks-19">Remarks</h4>
<p>Remarks</p>
<p>A simple path gradient brush has two colors: a boundary color and a center color. When you paint with such a brush, the color changes gradually from the boundary color to the center color as you move from the boundary path to the center point. You can create a more complex gradient by specifying an array of preset colors and an array of blend positions.</p>
<p>You can obtain the interpolation colors and interpolation positions currently set for a <strong>PathGradientBrush</strong> object by calling the <strong>GetInterpolationColors</strong> method of that <strong>PathGradientBrush</strong> object. Before you call the <strong>GetInterpolationColors</strong> method, you must allocate two buffers: one to hold the array of interpolation colors and one to hold the array of interpolation positions. You can call the <strong>GetInterpolationColorCount</strong> method of the <strong>PathGradientBrush</strong> object to determine the required size of those buffers. The size of the color buffer is the return value of <strong>GetInterpolationColorCount</strong> multiplied by 4. The size of the position buffer is the value of <strong>GetInterpolationColorCount</strong> multiplied by 4 (the size of a single precision number).</p>
<h1 id="getinterpolationcolors-(cgppathgradientbrush)"><a name="GetInterpolationColorsPGBrush"></a>GetInterpolationColors (CGpPathGradientBrush)</h1>
<p>Gets preset colors and blend positions currently specified for this path gradient brush.</p>
<pre><code>FUNCTION GetInterpolationColors (BYVAL presetColors AS ARGB PTR, _
   BYVAL blendPositions AS SINGLE PTR, BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>presetColors</em></td>
<td>Pointer to an array that receives the colors. A color of a given index in the presetColors array corresponds to the blend position of that same index in the <em>blendPositions</em> array.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array that receives the blend positions. Each blend position is a number from 0 through 1, where 0 indicates the boundary of the gradient and 1 indicates the center point. A blend position between 0 and 1 indicates the set of all points that are a certain fraction of the distance from the boundary to the center point. For example, a blend position of 0.7 indicates the set of all points that are 70 percent of the way from the boundary to the center point.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Integer that specifies the number of elements in the <em>presetColorsarray</em>. This is the same as the number of elements in the <em>blendPositions</em> array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-37">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-20">Remarks</h4>
<p>A simple path gradient brush has two colors: a boundary color and a center color. When you paint with such a brush, the color changes gradually from the boundary color to the center color as you move from the boundary path to the center point. You can create a more complex gradient by specifying an array of preset colors and an array of blend positions.</p>
<p>Before you call the GetInterpolationColors method, you must allocate two buffers: one to hold the array of preset colors and one to hold the array of blend positions. You can call the <strong>GetInterpolationColorCount</strong> method of the <strong>PathGradientBrush</strong> object to determine the required size of those buffers. The size of the color buffer is the return value of <strong>GetInterpolationColorCount</strong> multiplied by 4. The size of the position buffer is the value of <strong>GetInterpolationColorCount</strong> multiplied by 4 (the size of a single precision number).</p>
<h4 id="example-31">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object from a triangular path. The code
' sets the preset colors to red, blue, and aqua and sets the blend positions to 0, 0.6, and 1.
' The code calls the PathGradientBrush.GetInterpolationColorCount method of the PathGradientBrush
' object to obtain the number of preset colors currently set for the brush. Next, the code
' allocates two buffers: one to hold the array of preset colors, and one to hold the array
' of blend positions. The call to the PathGradientBrush.GetInterpolationColors method of
' the PathGradientBrush object fills the buffers with the preset colors and the blend positions.
' Finally the code fills a small square with each of the preset colors.
' ========================================================================================
SUB Example_GetInterpolationColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(100, 0), GDIP_POINT(200, 200), GDIP_POINT(0, 200)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 255)}
   DIM positions(0 TO 2) AS SINGLE = {0.0, 0.6, 1.0}

   pthGrBrush.SetInterpolationColors(@colors(0), @positions(0), 3)

   ' // Obtain information about the path gradient brush.
   DIM colorCount AS LONG = pthGrBrush.GetInterpolationColorCount
   DIM rgColors(colorCount - 1) AS ARGB
   DIM rgPositions(colorCount - 1) AS SINGLE
   pthGrBrush.GetInterpolationColors(@rgColors(0), @rgPositions(0), colorCount)

   ' // Fill a small square with each of the interpolation colors.
   DIM solidBrush AS CGpSolidBrush = GDIP_ARGB(255, 255, 255, 255)

   FOR j AS LONG = 0 TO colorCount - 1
      solidBrush.SetColor(rgColors(j))
      graphics.FillRectangle(@solidBrush, 15 * j, 0, 10, 10)
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getpointcount-(cgppathgradientbrush)"><a name="GetPointCount"></a>GetPointCount (CGpPathGradientBrush)</h1>
<p>Gets the number of points in the array of points that defines this brush's boundary path.</p>
<pre><code>FUNCTION GetPointCount () AS INT_
</code></pre>
<h4 id="return-value-38">Return value</h4>
<p>This method returns the number of points in the array of points that defines this brush's boundary path.</p>
<h1 id="getrectangle-(cgppathgradientbrush)"><a name="GetRectanglePGBrush"></a>GetRectangle (CGpPathGradientBrush)</h1>
<p>Gets the smallest rectangle that encloses the boundary path of this path gradient brush.</p>
<pre><code>FUNCTION GetRectangle (BYVAL rc AS GpRectF PTR) AS GpStatus
FUNCTION GetRectangle (BYVAL rc AS GpRect PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>rc</em></td>
<td>Pointer to a <strong>GpRectF</strong> or <strong>GpRect</strong> structure that receives the bounding rectangle.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-39">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-32">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a polygon that is defined
' by four points. The code calls the PathGradientBrush::GetRectangle method of the
' PathGradientBrush object to obtain the smallest rectangle that encloses the brush's
' boundary path. The code calls the Graphics.FillRectangle method of a Graphics object,
' passing the address of the PathGradientBrush object and a reference to the brush's bounding
' rectangle. That call fills only the portion of the bounding rectangle that is inside the
' brush's boundary path. Finally the code draws the outline of the bounding rectangle.
' ========================================================================================
SUB Example_GetRectangle (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM pen AS CGpPen = GDIP_ARGB(255, 0, 0, 0)

   ' // Create a path gradient brush based on an array of points.
   DIM points(0 TO 3) AS GpPoint = {GDIP_POINT(30, 20), GDIP_POINT(150, 40), GDIP_POINT(100, 100), GDIP_POINT(60, 200)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 4)

   ' // Obtain information about the path gradient brush.
   DIM rc AS GpRectF
   pthGrBrush.GetRectangle(@rc)

   graphics.FillRectangle(@pthGrBrush, @rc)
   graphics.DrawRectangle(@pen, @rc)

END SUB
' ========================================================================================
</code></pre>
<h1 id="getsurroundcolorcount-(cgppathgradientbrush)"><a name="GetSurroundColorCount"></a>GetSurroundColorCount (CGpPathGradientBrush)</h1>
<p>Gets the number of colors that have been specified for the boundary path of this path gradient brush.</p>
<pre><code>FUNCTION GetSurroundColorCount () AS INT_
</code></pre>
<h4 id="return-value-40">Return value</h4>
<p>This method returns the number of colors that have been specified for the boundary path of this path gradient brush.</p>
<h4 id="example-33">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path that
' is defined by an array of three points. The code calls the PathGradientBrush.SetSurroundColors
' method of the PathGradientBrush object to specify a color for each of the points that
' define the triangle. The PathGradientBrush.GetSurroundColorCount method determines the
' current number of surround colors (the colors specified for the brush's boundary path).
' Next, the code allocates a buffer large enough to receive the array of surround colors
' and calls PathGradientBrush.GetSurroundColors to fill that buffer. Finally the code fills
' a small square with each of the brush's surround colors.
' ========================================================================================
SUB Example_GetSurroundColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(100, 0), GDIP_POINT(200, 200), GDIP_POINT(0, 200)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM nCount AS LONG = 3
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 255)}
   pthGrBrush.SetSurroundColors(@colors(0), @nCount)

   ' // Obtain information about the path gradient brush.
   DIM colorCount AS LONG = pthGrBrush.GetSurroundColorCount
   DIM rgColors(colorCount - 1) AS ARGB
   pthGrBrush.GetSurroundColors(@rgColors(0), @colorCount)

   ' // Fill a small square with each of the surround colors.
   DIM solidBrush AS CGpSolidBrush = GDIP_ARGB(255, 255, 255, 255)
   FOR j AS LONG = 0 TO colorCount - 1
      solidBrush.SetColor(rgColors(j))
      graphics.FillRectangle(@solidBrush, 15 * j, 0, 10, 10)
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getsurroundcolors-(cgppathgradientbrush)"><a name="GetSurroundColors"></a>GetSurroundColors (CGpPathGradientBrush)</h1>
<p>Gets the surround colors currently specified for this path gradient brush.</p>
<pre><code>FUNCTION GetSurroundColors (BYVAL colors AS ARGB PTR, BYVAL count AS INT_ PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colors</em></td>
<td>Pointer to an array that receives the surround colors.</td>
</tr>
<tr class="even">
<td><em>count</em></td>
<td>Out. Pointer to an integer that, on input, specifies the number of colors requested. If the method succeeds, this parameter, on output, receives the number of colors retrieved. If the method fails, this parameter does not receive a value.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-41">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-21">Remarks</h4>
<p>A path gradient brush has a boundary path and a center point. The center point is set to a single color, but you can specify different colors for several points on the boundary. For example, suppose you specify red for the center color, and you specify blue, green, and yellow for distinct points on the boundary. Then as you move along the boundary, the color will change gradually from blue to green to yellow and back to blue. As you move along a straight line from any point on the boundary to the center point, the color will change from that boundary point's color to red.</p>
<h4 id="example-34">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path that
' is defined by an array of three points. The code calls the PathGradientBrush.SetSurroundColors
' method of the PathGradientBrush object to specify a color for each of the points that
' define the triangle. The PathGradientBrush.GetSurroundColorCount method determines the
' current number of surround colors (the colors specified for the brush's boundary path).
' Next, the code allocates a buffer large enough to receive the array of surround colors
' and calls PathGradientBrush.GetSurroundColors to fill that buffer. Finally the code fills
' a small square with each of the brush's surround colors.
' ========================================================================================
SUB Example_GetSurroundColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(100, 0), GDIP_POINT(200, 200), GDIP_POINT(0, 200)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM nCount AS LONG = 3
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 255)}
   pthGrBrush.SetSurroundColors(@colors(0), @nCount)

   ' // Obtain information about the path gradient brush.
   DIM colorCount AS LONG = pthGrBrush.GetSurroundColorCount
   DIM rgColors(colorCount - 1) AS ARGB
   pthGrBrush.GetSurroundColors(@rgColors(0), @colorCount)

   ' // Fill a small square with each of the surround colors.
   DIM solidBrush AS CGpSolidBrush = GDIP_ARGB(255, 255, 255, 255)
   FOR j AS LONG = 0 TO colorCount - 1
      solidBrush.SetColor(rgColors(j))
      graphics.FillRectangle(@solidBrush, 15 * j, 0, 10, 10)
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="gettransform-(cgppathgradientbrush)"><a name="GetTransformPGBrush"></a>GetTransform (CGpPathGradientBrush)</h1>
<p>Gets the transformation matrix of this path gradient brush.</p>
<pre><code>FUNCTION GetTransform (BYVAL pMatrix AS CGpMatrix PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a <strong>Matrix</strong> object that receives the transformation matrix.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-42">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-22">Remarks</h4>
<p>A <strong>PathGradientBrush</strong> object maintains a transformation matrix that can store any affine transformation. When you use a path gradient brush to fill an area, GDI+ transforms the brush's boundary path according to the brush's transformation matrix and then fills the interior of the transformed path. The transformed path exists only during rendering; the boundary path stored in <strong>PathGradientBrush</strong> object is not transformed.</p>
<h4 id="example-35">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on an array of three points.
' The PathGradientBrush.ScaleTransform and PathGradientBrush.TranslateTransform methods set
' the elements of the brush's transformation matrix so that the matrix represents a composite
' transformation (first scale, then translate). That composite transformation applies to
' the brush's boundary path, so the call to FillRectangle fills the interior of a triangle
' that is the result of scaling and translating the boundary path. The code calls the
' PathGradientBrush.GetTransform method of the PathGradientBrush object to obtain the brush's
' transformation matrix and then calls the GetElements method of the retrieved Matrix object
' to fill an array with the matrix elements.
' ========================================================================================
SUB Example_GetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(50, 0), GDIP_POINT(50, 50)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   pthGrBrush.ScaleTransform(3.0, 1.0)
   pthGrBrush.TranslateTransform(10.0, 30.0, MatrixOrderAppend)

   graphics.FillRectangle(@pthGrBrush, 0, 0, 200, 200)

   ' // Obtain information about the path gradient brush.
   DIM matrix AS CGpMatrix
   DIM elements(0 TO 5) AS SINGLE

   pthGrBrush.GetTransform(@matrix)
   matrix.GetElements(@elements(0))

   FOR j AS LONG = 0 TO 5
      ' // Inspect or use the value in elements(j)
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getwrapmode-(cgppathgradientbrush)"><a name="GetWrapModePGBrush"></a>GetWrapMode (CGpPathGradientBrush)</h1>
<p>Gets the wrap mode currently set for this path gradient brush.</p>
<pre><code>FUNCTION GetWrapMode () AS WrapMode
</code></pre>
<h4 id="return-value-43">Return value</h4>
<p>This method returns an element of the <strong>WrapMode</strong> enumeration that indicates the wrap mode currently set for this path gradient brush.</p>
<h4 id="remarks-23">Remarks</h4>
<p>The bounding rectangle of a path gradient brush is the smallest rectangle that encloses the brush's boundary path. When you paint the bounding rectangle with the path gradient brush, only the area inside the boundary path gets filled. The area inside the bounding rectangle but outside the boundary path does not get filled.</p>
<p>The default wrap mode for a path gradient brush is <strong>WrapModeClamp</strong>, which indicates that no painting occurs outside of the brush's bounding rectangle. All of the other wrap modes indicate that areas outside the brush's bounding rectangle will be tiled. Each tile is a copy (possibly flipped) of the filled path inside its bounding rectangle.</p>
<h4 id="example-36">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' code calls the PathGradientBrush.SetWrapMode method of the PathGradientBrush object to
' set the wrap mode to WrapModeTileFlipX. Next, the code calls the PathGradientBrush.GetWrapMode
' method of the PathGradientBrush object to obtain the brush's wrap mode. If the obtained
' wrap mode is WrapModeTileFlipX, the code calls FillRectangle to tile a large area with
' the path gradient brush. 
' ========================================================================================
SUB Example_GetWrapMode (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(100, 0), GDIP_POINT(100, 100)}
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 0)}

   DIM nCount AS LONG = 3
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)
   pthGrBrush.SetSurroundColors(@colors(0), @nCount)
   pthGrBrush.SetWrapMode(WrapModeTileFlipX)

   ' // Obtain information about the path gradient brush.
   DIM nWrapMode AS WrapMode = pthGrBrush.GetWrapMode

   IF nWrapMode = WrapModeTileFlipX THEN
      graphics.FillRectangle(@pthGrBrush, 0, 0, 800, 800)
   END IF

END SUB
' ========================================================================================
</code></pre>
<h1 id="multiplytransform-(cgppathgradientbrush)"><a name="MultiplyTransformPGBrush"></a>MultiplyTransform (CGpPathGradientBrush)</h1>
<p>Updates the brush's transformation matrix with the product of itself and another matrix.</p>
<pre><code>FUNCTION MultiplyTransform (BYVAL pMatrix AS CGpMatrix PTR, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a matrix to be multiplied by the brush's current transformation matrix.</td>
</tr>
<tr class="even">
<td><em>order</em></td>
<td>Optional. Element of the <strong>MatrixOrder</strong> enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-44">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-24">Remarks</h4>
<p>A single 3 ×3 matrix can store any sequence of affine transformations. If you have several 3 ×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3 ×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix R represents a rotation and matrix T represents a translation. If matrix M is the product RT, then matrix M represents a composite transformation: first rotate, then translate.</p>
<p>The order of matrix multiplication is important. In general, the matrix product RT is not the same as the matrix product TR. In the example given in the previous paragraph, the composite transformation represented by RT (first rotate, then translate) is not the same as the composite transformation represented by TR (first translate, then rotate).</p>
<h4 id="example-37">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' code calls the PathGradientBrush.ScaleTransform method of the PathGradientBrush object
' to fill the brush's transformation matrix with the elements that represent a horizontal
' scaling by a factor of 3. Then the code calls the PathGradientBrush.MultiplyTransform
' method of that same PathGradientBrush object to multiply the brush's existing transformation
' matrix by a matrix that represents a translation (10 right, 30 down). The MatrixOrderAppend
' argument indicates that the multiplication is performed with the translation matrix on the right.
' After the multiplication, the brush's transformation matrix represents a composite
' transformation: first scale, then translate. That composite transformation is applied to
' the brush's boundary path during the call to FillRectangle, so it is the area inside the
' transformed path that gets painted.
' ========================================================================================
SUB Example_MultiplyTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(50, 0), GDIP_POINT(50, 50)}

   ' // Translate 10 right, 30 down.
   DIM Matrix AS CGpMatrix = CGpMatrix(1.0, 0.0, 0.0, 1.0, 10.0, 30.0)

   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)
   pthGrBrush.ScaleTransform(3.0, 1.0)
   pthGrBrush.MultiplyTransform(@matrix, MatrixOrderAppend)

   graphics.FillRectangle(@pthGrBrush, 0, 0, 200, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="resettransform-(cgppathgradientbrush)"><a name="ResetTransformPGBrush"></a>ResetTransform (CGpPathGradientBrush)</h1>
<p>Resets the transformation matrix of this path gradient brush to the identity matrix. This means that no transformation will take place.</p>
<pre><code>FUNCTION ResetTransform () AS GpStatus
</code></pre>
<h4 id="return-value-45">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-38">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' code calls the PathGradientBrush.ScaleTransform method of the PathGradientBrush object
' to fill the brush's transformation matrix with the elements that represent a horizontal
' scaling by a factor of 3. Then the code calls the PathGradientBrush.MultiplyTransform
' method of that same PathGradientBrush object to multiply the brush's existing transformation
' matrix by a matrix that represents a translation (10 right, 30 down). The MatrixOrderAppend
' argument indicates that the multiplication is performed with the translation matrix on the right.
' After the multiplication, the brush's transformation matrix represents a composite
' transformation: first scale, then translate. That composite transformation is applied to
' the brush's boundary path during the call to FillRectangle, so it is the area inside the
' transformed path that gets painted.
' ========================================================================================
SUB Example_ResetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(50, 0), GDIP_POINT(50, 50)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   pthGrBrush.ScaleTransform(3.0, 1.0)
   pthGrBrush.TranslateTransform(100.0, 50.0, MatrixOrderAppend)

   ' // Fill an area with the transformed path gradient brush.
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

   pthGrBrush.ResetTransform

   ' // Fill the same area with the path gradient brush (no transformation).
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

END SUB
' ========================================================================================
</code></pre>
<h1 id="rotatetransform-(cgppathgradientbrush)"><a name="RotateTransformPGBrush"></a>RotateTransform (CGpPathGradientBrush)</h1>
<p>Updates this brush's current transformation matrix with the product of itself and a rotation matrix.</p>
<pre><code>FUNCTION RotateTransform (BYVAL angle AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>angle</em></td>
<td>Single precision number that specifies the angle of rotation in degrees.</td>
</tr>
<tr class="even">
<td><em>order</em></td>
<td>Optional. Element of the MatrixOrder enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-46">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-25">Remarks</h4>
<p>A single 3 ×3 matrix can store any sequence of affine transformations. If you have several 3 ×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3 ×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix T represents a translation and matrix R represents a rotation. If matrix M is the product TR, then matrix M represents a composite transformation: first translate, then rotate.</p>
<h4 id="example-39">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' calls to the PathGradientBrush.ScaleTransform and PathGradientBrush.RotateTransform methods
' of the PathGradientBrush object set the elements of the brush's transformation matrix so
' that it represents a composite transformation: first scale, then rotate. The code uses
' the path gradient brush twice to paint a rectangle: once before the transformation is set
' and once after the transformation is set.
' ========================================================================================
SUB Example_RotateTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(50, 0), GDIP_POINT(50, 50)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   ' // Fill an area with the path gradient brush (no transformation).
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

   pthGrBrush.ScaleTransform(3.0, 1.0)                   ' // first scale
   pthGrBrush.RotateTransform(60.0, MatrixOrderAppend)   ' // then rotate

   ' // Fill the same area with the transformed path gradient brush.
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

END SUB
' ========================================================================================
</code></pre>
<h1 id="scaletransform-(cgppathgradientbrush)"><a name="ScaleTransformPGBrush"></a>ScaleTransform (CGpPathGradientBrush)</h1>
<p>Updates this brush's current transformation matrix with the product of itself and a scaling matrix.</p>
<pre><code>FUNCTION ScaleTransform (BYVAL sx AS SINGLE, BYVAL sy AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>sx</em></td>
<td>Single precision number that specifies the horizontal scale factor.</td>
</tr>
<tr class="even">
<td><em>sy</em></td>
<td>Single precision number that specifies the vertical scale factor.</td>
</tr>
<tr class="odd">
<td><em>order</em></td>
<td>Optional. Element of the MatrixOrder enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-47">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-26">Remarks</h4>
<p>A single 3 ×3 matrix can store any sequence of affine transformations. If you have several 3 ×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3 ×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix T represents a translation and matrix S represents a scaling. If matrix M is the product TS, then matrix M represents a composite transformation: first translate, then scale.</p>
<h4 id="example-40">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' calls to the PathGradientBrush::TranslateTransform and PathGradientBrush.ScaleTransform
' methods of the PathGradientBrush object set the elements of the brush's transformation
' matrix so that it represents a composite transformation: first translate, then scale. The
' code uses the path gradient brush twice to paint a rectangle: once before the transformation
' is set and once after the transformation is set.
' ========================================================================================
SUB Example_ScaleTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(50, 0), GDIP_POINT(50, 50)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   ' // Fill an area with the path gradient brush (no transformation).
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

   pthGrBrush.TranslateTransform(50.0, 40.0)                ' // translate
   pthGrBrush.ScaleTransform(3.0, 2.0, MatrixOrderAppend)   ' // then scale

   ' // Fill the same area with the transformed path gradient brush.
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setblend-(cgppathgradientbrush)"><a name="SetBlendPGBrush"></a>SetBlend (CGpPathGradientBrush)</h1>
<p>Sets the blend factors and the blend positions of this path gradient brush.</p>
<pre><code>FUNCTION SetBlend (BYVAL blendFactors AS SINGLE PTR, BYVAL blendPositions AS SINGLE PTR, _
   BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>blendFactors</em></td>
<td>Pointer to an array of blend factors. Each number in the array should be in the range 0 through 1.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array of blend positions. Each number in the array should be in the range 0 through 1.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Optional. Integer that specifies the number of elements in the blendFactors array. This is the same as the number of elements in the <em>blendPositions</em> array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-48">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-27">Remarks</h4>
<p>A <strong>PathGradientBrush</strong> object has a boundary path and a center point. When you fill an area with a path gradient brush, the color changes gradually as you move from the boundary path to the center point. By default, the color is linearly related to the distance, but you can customize the relationship between color and distance by calling the <strong>SetBlend</strong> method.</p>
<h4 id="example-41">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on an ellipse. The code
' calls the PathGradientBrush::SetBlend method of the PathGradientBrush object to establish
' a set of blend factors and blend positions for the brush. Then the code uses the path
' gradient brush to fill the ellipse.
' ========================================================================================
SUB Example_SetBlend (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   ' // Set blend factors and positions for the path gradient brush.
   DIM factors(0 TO 3) AS SINGLE = {0.0, 0.4, 0.8, 1.0}
   DIM positions(0 TO 3) AS SINGLE = {0.0, 0.3, 0.7, 1.0}

   pthGrBrush.SetBlend(@factors(0), @positions(0), 4)

   ' // Fill the ellipse with the path gradient brush.
   graphics.FillEllipse(@pthGrBrush, 0, 0, 200, 100)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setblendbellshape-(cgppathgradientbrush)"><a name="SetBlendBellShapePGBrush"></a>SetBlendBellShape (CGpPathGradientBrush)</h1>
<p>Sets the blend shape of this path gradient brush.</p>
<pre><code>FUNCTION SetBlendBellShape (BYVAL focus AS SINGLE, BYVAL scale AS SINGLE = 1.0) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>focus</em></td>
<td>Single precision number that specifies where the center color will be at its highest intensity. This number must be in the range 0 through 1.</td>
</tr>
<tr class="even">
<td><em>scale</em></td>
<td>Single precision number that specifies the maximum intensity of center color that gets blended with the boundary color. This number must be in the range 0 through 1. The default value is 1.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-49">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-28">Remarks</h4>
<p>By default, as you move from the boundary of a path gradient to the center point, the color changes gradually from the boundary color to the center color. You can customize the positioning and blending of the boundary and center colors by calling the <strong>SetBlendBellShape</strong> method.</p>
<h4 id="example-42">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on an ellipse. The code
' calls the PathGradientBrush.SetBlendBellShape method of the PathGradientBrush object,
' passing a focus of 0.2 and a scale of 0.7. Then the code uses the path gradient brush to
' paint a rectangle that contains the ellipse.
' ========================================================================================
SUB Example_SetBlendBellShape (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   pthGrBrush.SetBlendBellShape(0.2, 0.7)

   ' // The color is blue on the boundary and at the center.
   ' // At points that are 20 percent of the way from the boundary to the
   ' // center, the color is 70 percent red and 30 percent blue.

   graphics.FillRectangle(@pthGrBrush, 0, 0, 300, 300)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setblendtriangularshape-(cgppathgradientbrush)"><a name="SetBlendTriangularShapePGBrush"></a>SetBlendTriangularShape (CGpPathGradientBrush)</h1>
<p>Sets the blend shape of this path gradient brush.</p>
<pre><code>FUNCTION SetBlendTriangularShape (BYVAL focus AS SINGLE, BYVAL scale AS SINGLE = 1.0) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>focus</em></td>
<td>Single precision number that specifies where the center color will be at its highest intensity. This number must be in the range 0 through 1.</td>
</tr>
<tr class="even">
<td><em>scale</em></td>
<td>Single precision number that specifies the maximum intensity of center color that gets blended with the boundary color. This number must be in the range 0 through 1. The default value is 1.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-50">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-29">Remarks</h4>
<p>By default, as you move from the boundary of a path gradient to the center point, the color changes gradually from the boundary color to the center color. You can customize the positioning and blending of the boundary and center colors by calling the <strong>SetBlendTriangularShape</strong> method.</p>
<h4 id="example-43">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on an ellipse. The code
' calls the PathGradientBrush.SetBlendTriangularShape method of the PathGradientBrush object,
' passing a focus of 0.2 and a scale of 0.7. Then the code uses the path gradient brush to
' paint a rectangle that contains the ellipse.
' ========================================================================================
SUB Example_SetBlendTriangularShape (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   pthGrBrush.SetBlendTriangularShape(0.2, 0.7)

   ' // The color is blue on the boundary and at the center.
   ' // At points that are 20 percent of the way from the boundary to the
   ' // center, the color is 70 percent red and 30 percent blue.

   graphics.FillRectangle(@pthGrBrush, 0, 0, 300, 300)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setcentercolor-(cgppathgradientbrush)"><a name="SetCenterColor"></a>SetCenterColor (CGpPathGradientBrush)</h1>
<p>Sets the center color of this path gradient brush. The center color is the color that appears at the brush's center point.</p>
<pre><code>FUNCTION SetCenterColor (BYVAL colour AS ARGB) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colour</em></td>
<td>ARGB color that specifies the center color.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-51">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-30">Remarks</h4>
<p>By default the center point is the centroid of the brush's boundary path, but you can set the center point to any location inside or outside the path.</p>
<h4 id="example-44">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on an ellipse. The code
' calls the PathGradientBrush.SetCenterColor method of the PathGradientBrush object to set
' the center color to blue. The PathGradientBrush.SetSurroundColors method sets the color
' along the entire boundary to aqua. The FillRectangle Methods method uses the path gradient
' brush to paint a rectangle that contains the ellipse.
' ========================================================================================
SUB Example_SetCenterColor (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   ' // Fill the ellipse with the path gradient brush.
   graphics.FillEllipse(@pthGrBrush, 0, 0, 200, 100)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setcenterpoint-(cgppathgradientbrush)"><a name="SetCenterPoint"></a>SetCenterPoint (CGpPathGradientBrush)</h1>
<p>Sets the center point of this path gradient brush. By default, the center point is at the centroid of the brush's boundary path, but you can set the center point to any location inside or outside the path.</p>
<pre><code>FUNCTION SetCenterPoint (BYVAL pt AS PointF PTR) AS GpStatus
FUNCTION SetCenterPoint (BYVAL pt AS Point PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pt</em></td>
<td>Reference to a <strong>PointF</strong> or <strong>Point</strong> structure that specifies the center point.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-52">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-45">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on an ellipse. The code
' sets the center color to blue and sets the color along the boundary to aqua. By default,
' the center point would be at the center of the ellipse (100, 50), but the call to the
' PathGradientBrush.SetCenterPoint method sets the center point to (180.5, 50.0).
' ========================================================================================
SUB Example_SetCenterPoint (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a path that consists of a single ellipse.
   DIM path AS CGpGraphicsPath
   path.AddEllipse(0, 0, 200, 100)

   ' // Use the path to construct a brush.
   DIM pthGrBrush AS CGpPathGradientBrush = @path

   ' // Set the color at the center of the path to blue.
   pthGrBrush.SetCenterColor(GDIP_ARGB(255, 0, 0, 255))

   ' // Set the center point.
   DIM pt AS GpPointF = GDIP_POINTF(180.5, 50.0)
   pthGrBrush.SetCenterPoint(@pt)

   ' // Set the color along the entire boundary of the path to aqua.
   DIM colors(0) AS ARGB = {GDIP_ARGB(255, 0, 255, 255)}
   DIM count AS LONG = 1
   pthGrBrush.SetSurroundColors(@colors(0), @count)

   graphics.FillRectangle(@pthGrBrush, 0, 0, 300, 300)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setfocusscales-(cgppathgradientbrush)"><a name="SetFocusScales"></a>SetFocusScales (CGpPathGradientBrush)</h1>
<p>Sets the focus scales of this path gradient brush.</p>
<pre><code>FUNCTION SetFocusScales (BYVAL xScale AS SINGLE, BYVAL yScale AS SINGLE) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>xScale</em></td>
<td>Single precision number that specifies the x focus scale.</td>
</tr>
<tr class="even">
<td><em>yScale</em></td>
<td>Single precision number that specifies the y focus scale.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-53">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-31">Remarks</h4>
<p>By default, the center color of a path gradient is at the center point. By calling <strong>SetFocusScales</strong>, you can specify that the center color should appear along a path that surrounds the center point. That path is the boundary path scaled by a factor of <em>xScale</em> in the x direction and by a factor of <em>yScale</em> in the y direction. The area inside the scaled path is filled with the center color.</p>
<h4 id="example-46">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' code calls the PathGradientBrush::SetFocusScales method of the PathGradientBrush object
' to set the brush's focus scales to (0.2, 0.2). Then the code uses the path gradient brush
' to paint a rectangle that includes the triangular path.
' ========================================================================================
SUB Example_SetFocusScales (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(100, 0), GDIP_POINT(200, 200), GDIP_POINT(0, 200)}

   ' // No GraphicsPath object is created. The PathGradientBrush
   ' // object is constructed directly from the array of points.
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM colors(0 TO 1) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255)}

   ' // red at the boundary of the outer triangle
   ' // blue at the boundary of the inner triangle
   DIM relativePositions(0 TO 1) AS SINGLE = {0.0, 1.0}
   pthGrBrush.SetInterpolationColors(@colors(0), @relativePositions(0), 2)

   ' // The inner triangle is formed by scaling the outer triangle
   ' // about its centroid. The scaling factor is 0.2 in both the x and y directions.
   pthGrBrush.SetFocusScales(0.2, 0.2)

   ' // Fill a rectangle that is larger than the triangle
   ' // specified in the Point array. The portion of the
   ' // rectangle outside the triangle will not be painted.
   graphics.FillRectangle(@pthGrBrush, 0, 0, 200, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setinterpolationcolors-(cgppathgradientbrush)"><a name="SetInterpolationColorsPGBrush"></a>SetInterpolationColors (CGpPathGradientBrush)</h1>
<p>Sets the preset colors and the blend positions of this path gradient brush.</p>
<pre><code>FUNCTION SetInterpolationColors (BYVAL presetColors AS ARGB PTR, _
   BYVAL blendPositions AS SINGLE PTR, BYVAL count AS LONG) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>presetColors</em></td>
<td>Pointer to an array of colors that specifies the interpolation colors for the gradient. A color of a given index in the presetColors array corresponds to the blend position of that same index in the <em>blendPositions</em> array.</td>
</tr>
<tr class="even">
<td><em>blendPositions</em></td>
<td>Pointer to an array that specifies the blend positions. Each blend position is a number from 0 through 1, where 0 indicates the boundary of the gradient and 1 indicates the center point. A blend position between 0 and 1 specifies the set of all points that are a certain fraction of the distance from the boundary to the center point. For example, a blend position of 0.7 specifies the set of all points that are 70 percent of the way from the boundary to the center point.</td>
</tr>
<tr class="odd">
<td><em>count</em></td>
<td>Integer that specifies the number of elements in the <em>presetColors</em> array. This is the same as the number of elements in the blendPositions array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-54">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-47">Example</h4>
<p>A simple path gradient brush has two colors: a boundary color and a center color. When you paint with such a brush, the color changes gradually from the boundary color to the center color as you move from the boundary path to the center point. You can create a more complex gradient by specifying an array of preset colors and an array of blend positions.</p>
<h4 id="example-48">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' PathGradientBrush.SetInterpolationColors method sets the brush's preset colors to red,
' blue, and aqua and sets the blend positions to 0, 0, 4, and 1. The Graphics.FillRectangle
' method uses the path gradient brush to paint a rectangle that contains the triangular path.
' ========================================================================================
SUB Example_SetInterpolationColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(100, 0), GDIP_POINT(200, 200), GDIP_POINT(0, 200)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 255)}
   DIM positions(0 TO 2) AS SINGLE = {0.0, 0.4, 1.0}

   pthGrBrush.SetInterpolationColors(@colors(0), @positions(0), 3)
   graphics.FillRectangle(@pthGrBrush, 0, 0, 300, 300)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setsurroundcolors-(cgppathgradientbrush)"><a name="SetSurroundColors"></a>SetSurroundColors (CGpPathGradientBrush)</h1>
<p>Sets the surround colors of this path gradient brush. The surround colors are colors specified for discrete points on the brush's boundary path.</p>
<pre><code>FUNCTION SetSurroundColors (BYVAL colors AS ARGB PTR, BYVAL count AS INT_ PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>colors</em></td>
<td>Pointer to an array of colors that specify the surround colors.</td>
</tr>
<tr class="even">
<td><em>count</em></td>
<td>Out. Pointer to an integer that, on input, specifies the number of colors in the colors array. If the method succeeds, this parameter, on output, receives the number of surround colors set. If the method fails, this parameter does not receive a value.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-55">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-32">Remarks</h4>
<p>A path gradient brush has a boundary path and a center point. The center point is set to a single color, but you can specify different colors for several points on the boundary. For example, suppose you specify red for the center color, and you specify blue, green, and yellow for distinct points on the boundary. Then as you move along the boundary, the color will change gradually from blue to green to yellow and back to blue. As you move along a straight line from any point on the boundary to the center point, the color will change from that boundary point's color to red.</p>
<h4 id="example-49">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on an array of three points
' that defines a triangular path. The code also initializes an array of three Color objects.
' The call to the PathGradientBrush::SetSurroundColors method associates each color in the
' color array with the corresponding (same index) point in the point array. After the surround
' colors of the path gradient brush have been set, the Graphics.FillRectangle method uses
' the path gradient brush to paint a rectangle that includes the triangular path.
' One edge of the rendered triangle changes gradually from red to green. The next edge
' changes gradually from green to black, and the third edge changes gradually from black
' to red. The code does not set the center color, so the center color has the default value
' of black. As you move along a straight line from any point on the boundary path (triangle)
' to the center point, the color changes gradually from that boundary point's color to black.
' ========================================================================================
SUB Example_SetSurroundColors (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(20, 20), GDIP_POINT(100, 20), GDIP_POINT(100, 100)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM nCount AS LONG = 3
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 255)}
   pthGrBrush.SetSurroundColors(@colors(0), @nCount)

   graphics.FillRectangle(@pthGrBrush, 0, 0, 200, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="settransform-(cgppathgradientbrush)"><a name="SetTransformPGBrush"></a>SetTransform (CGpPathGradientBrush)</h1>
<p>Sets the transformation matrix of this path gradient brush.</p>
<pre><code>FUNCTION SetTransform (BYVAL pMatrix AS CGpMatrix PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a <strong>Matrix</strong> object that specifies the transformation matrix to use.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-56">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-33">Remarks</h4>
<p>A <strong>PathGradientBrush</strong> object has a <strong>GraphicsPath</strong> object that serves as the boundary path for the brush. When you paint with a path gradient brush, only the area inside the boundary path is filled. If the brush's transformation matrix is set to represent any transformation other than the identity, then the boundary path is transformed according to that matrix during rendering, and only the area inside the transformed path is filled.</p>
<p>The transformation applies only during rendering. The boundary path stored by the <strong>PathGradientBrush</strong> object is not altered by the <strong>SetTransform</strong> method.</p>
<p>Example</p>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' Graphics.FillRectangle method uses the path gradient brush to paint a rectangle that
' contains the triangular path. Next, the code creates a Matrix object that represents a
' composite transformation (rotate, then translate) and passes the address of that Matrix
' object to the PathGradientBrush.SetTransform method of the PathGradientBrush object. The
' code calls FillRectangle a second time to paint the same rectangle using the transformed
' path gradient brush.
' ========================================================================================
SUB Example_SetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(100, 0), GDIP_POINT(100, 100)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   DIM nCount AS LONG = 3
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 255, 0), GDIP_ARGB(255, 0, 0, 0)}
   pthGrBrush.SetSurroundColors(@colors(0), @nCount)

   graphics.FillRectangle(@pthGrBrush, 0, 0, 200, 200)

   ' // Set the transformation for the brush (rotate, then translate).
   DIM matrix AS CGpMatrix = CGpMatrix(0.0, 1.0, -1.0, 0.0, 150.0, 60.0)
   pthGrBrush.SetTransform(@matrix)
   
   ' // Fill the same area with the transformed path gradient brush.
   graphics.FillRectangle(@pthGrBrush, 0, 0, 200, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setwrapmode-(cgppathgradientbrush)"><a name="SetWrapModePGBrush"></a>SetWrapMode (CGpPathGradientBrush)</h1>
<p>Sets the wrap mode of this path gradient brush.</p>
<pre><code>FUNCTION SetWrapMode (BYVAL wrapMode AS WrapMode) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>wrapMode</em></td>
<td>Element of the <strong>WrapMode</strong> enumeration that specifies how areas painted with the path gradient brush will be tiled. The default value is <strong>WrapModeClamp</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-57">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-34">Remarks</h4>
<p>The bounding rectangle of a path gradient brush is the smallest rectangle that encloses the brush's boundary path. When you paint the bounding rectangle with the path gradient brush, only the area inside the boundary path gets filled. The area inside the bounding rectangle but outside the boundary path does not get filled.</p>
<p><strong>WrapModeClamp</strong> (the default wrap mode) indicates that no painting occurs outside of the brush's bounding rectangle. All of the other wrap modes indicate that areas outside the brush's bounding rectangle will be tiled. Each tile is a copy (possibly flipped) of the filled path inside its bounding rectangle.</p>
<h4 id="example-50">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' code calls the PathGradientBrush::SetWrapMode method of the PathGradientBrush object to
' set the brush's wrap mode to WrapModeTileFlipX. The Graphics::FillRectangle method uses
' the path gradient brush to tile a large area.
' The output of the code is a grid of tiles. As you move from one tile to the next in a
' given row, the image (filled boundary path inside the bounding rectangle) is flipped
' horizontally.
' ========================================================================================
SUB Example_SetWrapMode (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(100, 0), GDIP_POINT(100, 100)}
   DIM colors(0 TO 2) AS ARGB = {GDIP_ARGB(255, 255, 0, 0), GDIP_ARGB(255, 0, 0, 255), GDIP_ARGB(255, 0, 255, 0)}

   DIM nCount AS LONG = 3
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)
   pthGrBrush.SetSurroundColors(@colors(0), @nCount)
   pthGrBrush.SetWrapMode(WrapModeTileFlipX)

   graphics.FillRectangle(@pthGrBrush, 0, 0, 800, 800)

END SUB
' ========================================================================================
</code></pre>
<h1 id="translatetransform-(cgppathgradientbrush)"><a name="TranslateTransformPGBrush"></a>TranslateTransform (CGpPathGradientBrush)</h1>
<p>Updates this brush's current transformation matrix with the product of itself and a translation matrix.</p>
<pre><code>FUNCTION TranslateTransform (BYVAL dx AS SINGLE, BYVAL dy AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>dx</em></td>
<td>Single precision number that specifies the horizontal component of the translation.</td>
</tr>
<tr class="even">
<td><em>dy</em></td>
<td>Single precision number that specifies the vertical component of the translation.</td>
</tr>
<tr class="odd">
<td><em>order</em></td>
<td>Optional. Element of the <strong>MatrixOrder</strong> enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-58">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-35">Remarks</h4>
<p>A single 3×3 matrix can store any sequence of affine transformations. If you have several 3×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix <em>S</em> represents a scaling and matrix <em>T</em> represents a translation. If matrix <em>M</em> is the product <em>ST</em>, then matrix <em>M</em> represents a composite transformation: first scale, then translate.</p>
<h4 id="example-51">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a PathGradientBrush object based on a triangular path. The
' calls to the PathGradientBrush.ScaleTransform and PathGradientBrush.TranslateTransform
' methods of the PathGradientBrush object set the elements of the brush's transformation
' matrix so that it represents a composite transformation: first scale, then translate.
' The code uses the path gradient brush twice to paint a rectangle: once before the
' transformation is set and once after the transformation is set.
' ========================================================================================
SUB Example_TranslateTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   DIM points(0 TO 2) AS GpPoint = {GDIP_POINT(0, 0), GDIP_POINT(50, 0), GDIP_POINT(50, 50)}
   DIM pthGrBrush AS CGpPathGradientBrush = CGpPathGradientBrush(@points(0), 3)

   ' // Fill an area with the path gradient brush (no transformation).
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

   pthGrBrush.ScaleTransform(3.0, 1.0)
   pthGrBrush.TranslateTransform(100.0, 50.0, MatrixOrderAppend)

   ' // Fill the same area with the transformed path gradient brush.
   graphics.FillRectangle(@pthGrBrush, 0, 0, 500, 500)

END SUB
' ========================================================================================
</code></pre>
<h1 id="constructors-(cgptexturebrush)"><a name="ConstructorsTBrush"></a>Constructors (CGpTextureBrush)</h1>
<p>Creates a texture brush.</p>
<pre><code>CONSTRUCTOR CGpTextureBrush (BYVAL pTextureBrush AS CGpTextureBrush PTR)
CONSTRUCTOR CGpTextureBrush (BYVAL pImage AS CGpImage PTR, BYVAL nWrapMode AS WrapMode = WrapModeTile)
CONSTRUCTOR CGpTextureBrush (BYVAL pImage AS CGpImage PTR, BYVAL dstRect AS GpRectF PTR, _
   BYVAL pImageAttributes AS CGpImageAttributes PTR = NULL)
CONSTRUCTOR CGpTextureBrush (BYVAL pImage AS CGpImage PTR, BYVAL dstRect AS GpRect PTR, _
   BYVAL pImageAttributes AS CGpImageAttributes PTR = NULL)
CONSTRUCTOR CGpTextureBrush (BYVAL pImage AS CGpImage PTR, BYVAL nWrapMode AS WrapMode, _
   BYVAL dstRect AS GpRect PTR)
CONSTRUCTOR CGpTextureBrush (BYVAL pImage AS CGpImage PTR, BYVAL nWrapMode AS WrapMode, _
   BYVAL dstX AS SINGLE, BYVAL dstY AS SINGLE, BYVAL dstWidth AS SINGLE, BYVAL dstHeight AS SINGLE)
CONSTRUCTOR CGpTextureBrush (BYVAL pImage AS CGpImage PTR, BYVAL nWrapMode AS WrapMode, _
   BYVAL dstX AS INT_, BYVAL dstY AS INT_, BYVAL dstWidth AS INT_, BYVAL dstHeight AS INT_)
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pImage</em></td>
<td>Pointer to a variable that will receive a pointer to the Image object that is defined by this texture brush.</td>
</tr>
<tr class="even">
<td><em>nWrapMode</em></td>
<td>Element of the <strong>WrapMode</strong> enumeration that specifies how repeated copies of an image are used to tile an area when it is painted with this texture brush.</td>
</tr>
<tr class="odd">
<td><em>dstX</em></td>
<td>Leftmost coordinate of the image portion to be used by this brush.</td>
</tr>
<tr class="even">
<td><em>dstY</em></td>
<td>Uppermost coordinate of the image portion to be used by this brush.</td>
</tr>
<tr class="odd">
<td><em>dstWidth</em></td>
<td>Width of the brush and width of the image portion to be used by the brush.</td>
</tr>
<tr class="even">
<td><em>dstHeight</em></td>
<td>Height of the brush and height of the image portion to be used by the brush.</td>
</tr>
<tr class="odd">
<td><em>dstHeight</em></td>
<td>Height of the brush and height of the image portion to be used by the brush.</td>
</tr>
</tbody>
</table>
<h4 id="remarks-36">Remarks</h4>
<p>The <em>dstX</em>, <em>dstY</em>, <em>dstWidth</em>, and <em>dstHeight</em> parameters specify a rectangle. The size of the brush is defined by dstWidth and dstHeight. The <em>dstX</em> and <em>dstY</em> parameters have no affect on the brush's size or position — the brush is always oriented at (0, 0). The <em>dstX</em>, <em>dstY</em>, <em>dstWidth</em>, and <em>dstHeight</em> parameters define the portion of the image to be used by the brush.</p>
<p>For example, suppose you have an image that is stored in an <strong>Image</strong> object and is 256 ×512 (width ×height) pixels. Then you create a <strong>TextureBrush</strong> object based on this image as follows:</p>
<pre><code>TextureBrush(@someImage, WrapModeTile, 12, 50, 100, 150)
</code></pre>
<p>The brush will have a width of 100 units and a height of 150 units. The brush will use a rectangular portion of the image. This portion begins at the pixel having coordinates (12, 50). The width and height of the portion are 100 and 150, respectively, measured from the starting pixel.</p>
<p>Now suppose you create another TextureBrush object based on the same image and specify a different rectangle:</p>
<pre><code>TextureBrush(@someImage, WrapModeTile, 0, 0, 256, 512)
</code></pre>
<p>The brush will have width and height equal to 256 and 512, respectively. The brush will use the entire image instead of a portion of it because the rectangle specifies a starting pixel at coordinates (0, 0) and dimensions identical to those of the image.</p>
<h1 id="getimage-(cgptexturebrush)"><a name="GetImage"></a>GetImage (CGpTextureBrush)</h1>
<p>Gets a pointer to the Image object that is defined by this texture brush.</p>
<pre><code>FUNCTION GetImage (BYVAL pImage AS CGpImage PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pImage</em></td>
<td>Pointer to a variable that will receive a pointer to the Image object that is defined by this texture brush.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-59">Return value</h4>
<p>This method returns the number of preset colors currently specified for this path gradient brush.</p>
<h4 id="return-value-60">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-52">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and uses it to fill an ellipse. The code
' then gets the brush's image and draws it.
' ========================================================================================
SUB Example_GetImage (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and use it to fill an ellipse.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   graphics.FillEllipse(@textureBrush, 0, 0, 200, 200)

   ' // Get the brush's image, and draw that image
   DIM pImage2 AS CGpImage
   textureBrush.GetImage(@pImage2)
   graphics.DrawImage(@pImage2, 10, 150)

END SUB
' ========================================================================================
</code></pre>
<h1 id="gettransform-(cgptexturebrush)"><a name="GetTransformTBrush"></a>GetTransform (CGpTextureBrush)</h1>
<p>Gets the transformation matrix of this texture brush.</p>
<pre><code>FUNCTION GetTransform (BYVAL pMatrix AS CGpMatrix PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a <strong>Matrix</strong> object that receives the transformation matrix.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-61">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-37">Remarks</h4>
<p>A <strong>TextureBrush</strong> object maintains a transformation matrix that can store any affine transformation. When you use a texture brush to fill an area, GDI+ transforms the brush's image according to the brush's transformation matrix and then fills the area. The transformed image exists only during rendering; the image stored in the <strong>TextureBrush</strong> object is not transformed. For example, suppose you call <em>someTextureBrush.ScaleTransform(3)</em> and then paint an area with <em>someTextureBrush</em>. The width of the brush's image triples when the area is painted, but the image stored in <em>someTextureBrush</em> remains unchanged.</p>
<h4 id="example-53">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and sets the transformation of the brush.
' The code then gets the brush's transformation matrix and proceeds to inspect or use the elements.
' ========================================================================================
SUB Example_GetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.ScaleTransform(3, 2)

   DIM matrix AS CGpMatrix
   DIM elements(5) AS SINGLE

   textureBrush.GetTransform(@matrix)
   matrix.GetElements(@elements(0))

   FOR j AS LONG = 0 TO 5
      ' // Inspect or use the value in elements[j].
      PRINT elements(j)
   NEXT

END SUB
' ========================================================================================
</code></pre>
<h1 id="getwrapmode-(cgptexturetbrush)"><a name="GetWrapModeTBrush"></a>GetWrapMode (CGpTexturetBrush)</h1>
<p>Gets the wrap mode currently set for this texture brush.</p>
<pre><code>FUNCTION GetWrapMode () AS WrapMode
</code></pre>
<h4 id="return-value-62">Return value</h4>
<p>This method returns the wrap mode currently set for this texture brush. The value returned is one of the elements of the <strong>WrapMode</strong> enumeration.</p>
<h4 id="example-54">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush, sets the wrap mode of the brush, and uses
' the brush to fill a rectangle. Next, the code gets the wrap mode of the brush and stores
' the value. The code creates a second texture brush and uses the stored wrap mode to set
' the wrap mode of the second texture brush. Then, the code uses the second texture brush
' to fill a rectangle.
' ========================================================================================
SUB Example_WrapMode (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.SetWrapMode(WrapModeTileFlipX)
   graphics.FillRectangle(@textureBrush, 0, 0, 200, 200)

   ' // Get the brush's wrap mode.
   DIM nWrapMode AS WrapMode = textureBrush.GetWrapMode

   ' // Create a second texture brush with the same wrap mode.
   DIM pImage2 AS CGpImage = &quot;MyTexture.png&quot;
   DIM textureBrush2 AS CGpTextureBrush = @pImage2
   textureBrush2.SetWrapMode(nWrapMode)
   graphics.FillRectangle(@textureBrush2, 210, 0, 200, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="multiplytransform-(cgptexturebrush)"><a name="MultiplyTransformTBrush"></a>MultiplyTransform (CGpTextureBrush)</h1>
<p>Updates the brush's transformation matrix with the product of itself and another matrix.</p>
<pre><code>FUNCTION MultiplyTransform (BYVAL pMatrix AS CGpMatrix PTR, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a matrix to be multiplied by the brush's current transformation matrix.</td>
</tr>
<tr class="even">
<td><em>order</em></td>
<td>Optional. Element of the <strong>MatrixOrder</strong> enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-63">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-55">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and sets the transformation of the brush.
' The code then uses the transformed brush to fill a rectangle.
' ========================================================================================
SUB Example_MultiplyTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Horizontal stretch
   DIM matrix AS CGpMatrix = CGpMatrix(3, 0, 0, 1, 0, 0)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage

   textureBrush.RotateTransform(30)   ' // rotate
   textureBrush.MultiplyTransform(@matrix, MatrixOrderAppend)   ' // stretch
   graphics.FillRectangle(@textureBrush, 0, 0, 400, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="resettransform-(cgptexturebrush)"><a name="ResetTransformTBrush"></a>ResetTransform (CGpTextureBrush)</h1>
<p>Resets the transformation matrix of this texture brush to the identity matrix. This means that no transformation takes place.</p>
<pre><code>FUNCTION ResetTransform () AS GpStatus
</code></pre>
<h4 id="return-value-64">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-56">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and sets the transformation of the brush.
' Next, the code uses the transformed brush to fill a rectangle. Then, the code resets the
' transformation of the brush and uses the untransformed brush to fill a rectangle.
' ========================================================================================
SUB Example_ResetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.RotateTransform(30)

   ' // Fill a rectangle with the transformed texture brush.
   graphics.FillEllipse(@textureBrush, 0, 0, 200, 100)

   ' // Reset the transformation
   textureBrush.ResetTransform

   ' // Fill a rectangle with the texture brush (no transformation).
   graphics.FillEllipse(@textureBrush, 210, 0, 200, 100)

END SUB
' ========================================================================================
</code></pre>
<h1 id="rotatetransform-(cgptexturebrush)"><a name="RotateTransformTBrush"></a>RotateTransform (CGpTextureBrush)</h1>
<p>Updates this texture brush's current transformation matrix with the product of itself and a rotation matrix.</p>
<pre><code>FUNCTION RotateTransform (BYVAL angle AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>angle</em></td>
<td>Single precision number that specifies the angle of rotation in degrees.</td>
</tr>
<tr class="even">
<td><em>order</em></td>
<td>Optional. Element of the MatrixOrder enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-65">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-38">Remarks</h4>
<p>A single 3×3 matrix can store any sequence of affine transformations. If you have several 3×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix R represents a rotation, and matrix T represents a translation. If matrix M is the product RT, then matrix M represents a composite transformation: first rotate, then translate.</p>
<p>The order of matrix multiplication is important. In general, the matrix product RT is not the same as the matrix product TR. In the example given in the previous paragraph, the composite transformation represented by RT (first rotate, then translate) is not the same as the composite transformation represented by TR (first translate, then rotate).</p>
<h4 id="example-57">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and sets the transformation of the brush.
' The code then uses the transformed brush to fill a rectangle.
' ========================================================================================
SUB Example_RotateTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.ScaleTransform(3, 1)
   textureBrush.RotateTransform(30, MatrixOrderAppend)
   graphics.FillEllipse(@textureBrush, 0, 0, 400, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="scaletransform-(cgptexturebrush)"><a name="ScaleTransformTBrush"></a>ScaleTransform (CGpTextureBrush)</h1>
<p>Updates this texture brush's current transformation matrix with the product of itself and a scaling matrix.</p>
<pre><code>FUNCTION ScaleTransform (BYVAL sx AS SINGLE, BYVAL sy AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>sx</em></td>
<td>Single precision number that specifies the amount to scale in the x direction.</td>
</tr>
<tr class="even">
<td><em>sy</em></td>
<td>Single precision number that specifies the amount to scale in the y direction.</td>
</tr>
<tr class="odd">
<td><em>order</em></td>
<td>Optional. Element of the MatrixOrder enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-66">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-39">Remarks</h4>
<p>A single 3×3 matrix can store any sequence of affine transformations. If you have several 3×3 matrices, each of which represents an affine transformation, the product of those matrices is a single 3×3 matrix that represents the entire sequence of transformations. The transformation represented by that product is called a composite transformation. For example, suppose matrix T represents a translation, and matrix S represents a scaling. If matrix M is the product TS, then matrix M represents a composite transformation: first translate, then scale.</p>
<p>The order of matrix multiplication is important. In general, the matrix product RT is not the same as the matrix product TR. In the example given in the previous paragraph, the composite transformation represented by RT (first rotate, then translate) is not the same as the composite transformation represented by TR (first translate, then rotate).</p>
<h4 id="example-58">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and sets the transformation of the brush.
' The code then uses the transformed brush to fill a rectangle.
' ========================================================================================
SUB Example_ScaleTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.RotateTransform(30)
   textureBrush.ScaleTransform(3, 1, MatrixOrderAppend)
   graphics.FillEllipse(@textureBrush, 0, 0, 400, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="settransform-(cgptexturebrush)"><a name="SetTransformTBrush"></a>SetTransform (CGpTextureBrush)</h1>
<p>Sets the transformation matrix of this texture brush.</p>
<pre><code>FUNCTION SetTransform (BYVAL pMatrix AS CGpMatrix PTR) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pMatrix</em></td>
<td>Pointer to a <strong>Matrix</strong> object that specifies the transformation matrix to use.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-67">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-40">Remarks</h4>
<p>A <strong>TextureBrush</strong> object maintains a transformation matrix that can store any affine transformation. When you use a texture brush to fill an area, Windows GDI+ transforms the brush's image according to the brush's transformation matrix and then fills the area. The transformed image exists only during rendering; the image stored in the TextureBrush object is not transformed. For example, suppose you call and then paint an area with <em>someTextureBrush.ScaleTransform(3)</em> and then paint an area with <em>someTextureBrush</em>. The width of the brush's image triples when the area is painted, but the image stored in someTextureBrush remains unchanged.</p>
<h4 id="example-59">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and sets the transformation of the brush.
' The code then uses the transformed brush to fill an ellipse.
' ========================================================================================
SUB Example_SetTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Horizontal stretch
   DIM matrix AS CGpMatrix = CGpMatrix(2, 0, 0, 1, 0, 0)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.SetTransform(@matrix)
   graphics.FillEllipse(@textureBrush, 0, 0, 400, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="setwrapmode-(cgptexturebrush)"><a name="SetWrapModeTBrush"></a>SetWrapMode (CGpTextureBrush)</h1>
<p>Sets the wrap mode of this texture brush.</p>
<pre><code>FUNCTION SetWrapMode (BYVAL wrapMode AS WrapMode) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>wrapMode</em></td>
<td>Element of the <strong>WrapMode</strong> enumeration that specifies how repeated copies of an image are used to tile an area when it is painted with this texture brush.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-68">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="remarks-41">Remarks</h4>
<p>An area that extends beyond the boundaries of the brush is tiled with repeated copies of the brush. A texture brush may have alternate tiles flipped in a certain direction, as specified by the wrap mode. Flipping has the effect of reversing the brush's image. For example, if the wrap mode is specified as <strong>WrapModeTileFlipX</strong>, the brush is flipped about a line that is parallel to the y-axis.</p>
<p>The texture brush is always oriented at (0, 0). If the wrap mode is specified as <strong>WrapModeClamp</strong>, no area outside of the brush is tiled. For example, suppose you create a texture brush, specifying <strong>WrapModeClamp</strong> as the wrap mode:</p>
<pre><code>TextureBrush(SomeImage, WrapModeClamp)
</code></pre>
<p>Then you paint an area with the brush. If the size of the brush has a height of 50 and the painted area is a rectangle with its upper-left corner at (0, 50), you will see no repeated copies of the brush (no tiling).</p>
<p>The default wrap mode for a texture brush is <strong>WrapModeTile</strong>, which specifies no flipping of the tile and no clamping.</p>
<h4 id="example-60">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush, sets the wrap mode of the brush, and uses
' the brush to fill a rectangle.
' ========================================================================================
SUB Example_SetWrapMode (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.SetWrapMode(WrapModeTileFlipX)
   graphics.FillRectangle(@textureBrush, 0, 0, 400, 200)

END SUB
' ========================================================================================
</code></pre>
<h1 id="translatetransform-(cgptexturebrush)"><a name="TranslateTransformTBrush"></a>TranslateTransform (CGpTextureBrush)</h1>
<p>Updates this brush's current transformation matrix with the product of itself and a translation matrix.</p>
<pre><code>FUNCTION TranslateTransform (BYVAL dx AS SINGLE, BYVAL dy AS SINGLE, _
   BYVAL order AS MatrixOrder = MatrixOrderPrepend) AS GpStatus
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>dx</em></td>
<td>Single precision number that specifies the horizontal component of the translation.</td>
</tr>
<tr class="even">
<td><em>dy</em></td>
<td>Single precision number that specifies the vertical component of the translation.</td>
</tr>
<tr class="odd">
<td><em>order</em></td>
<td>Optional. Element of the <strong>MatrixOrder</strong> enumeration that specifies the order of multiplication. <strong>MatrixOrderPrepend</strong> specifies that the passed matrix is on the left, and <strong>MatrixOrderAppend</strong> specifies that the passed matrix is on the right. The default value is <strong>MatrixOrderPrepend</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-69">Return value</h4>
<p>If the function succeeds, it returns <strong>Ok</strong>, which is an element of the <strong>Status</strong> enumeration.</p>
<p>If the function fails, it returns one of the other elements of the <strong>Status</strong> enumeration.</p>
<h4 id="example-61">Example</h4>
<pre><code>' ========================================================================================
' The following example creates a texture brush and sets the transformation of the brush.
' The code then uses the transformed brush to fill a rectangle.
' ========================================================================================
SUB Example_TranslateTransform (BYVAL hdc AS HDC)

   ' // Create a graphics object from the window device context
   DIM graphics AS CGpGraphics = hdc
   ' // Get the DPI scaling ratio
   DIM rxRatio AS SINGLE = graphics.GetDpiX / 96
   DIM ryRatio AS SINGLE = graphics.GetDpiY / 96
   ' // Set the scale transform
   graphics.ScaleTransform(rxRatio, ryRatio)

   ' // Create a texture brush, and set its transformation.
   DIM pImage AS CGpImage = &quot;HouseAndTree.gif&quot;
   DIM textureBrush AS CGpTextureBrush = @pImage
   textureBrush.TranslateTransform(30, 0, MatrixOrderAppend)
   graphics.FillEllipse(@textureBrush, 0, 0, 400, 200)

END SUB
' ========================================================================================
</code></pre>
</body>
</html>

